{
    "docs": [
        {
            "location": "/",
            "text": "Introdu\u00e7\u00e3o\n\n\nA biblioteca \nGoLedger CC-Tools\n \u00e9 um esfor\u00e7o colaborativo da empresa GoLedger para fornecer aos desenvolvedores uma biblioteca potente e de f\u00e1cil uso para a cria\u00e7\u00e3o de HLF chaincodes.\n\n\nDesenvolvida em GoLang, a biblioteca cc-tools possui diversas caracter\u00edsticas que facilitam a jornada de aprendizado, desenvolvimento e deployment em produ\u00e7\u00e3o de um chaincode para Hyperledger Fabric.\n\n\nA biblioteca CC-Tools est\u00e1 sendo disponibilizada como open-source pela empresa GoLedger para a comunidade de desenvolvimento Hyperledger.\n\n\nCaracter\u00edsticas\n\n\n\n\nMapeamento de dados dos assets (e suas propriedades) padronizado\n\n\nEncapsulamento das fun\u00e7\u00f5es de interface do sdk de chaincode Hyperledger Fabric \n\n\nGest\u00e3o dos asset keys padronizada\n\n\nDisponibiliza\u00e7\u00e3o de tipos b\u00e1sicos de propriedades dos assets (texto, n\u00famero, booleano, data)\n\n\nDisponibiliza\u00e7\u00e3o de tipos de listas de tipos b\u00e1sicos de propriedades dos assets (arrays de texto, n\u00famero ou data)\n\n\nCustomiza\u00e7\u00e3o de tipos de propriedades de assets\n\n\nGest\u00e3o de assets dentro de assets como refer\u00eancias\n\n\nGest\u00e3o de listas de refer\u00eancias de assets\n\n\nGest\u00e3o de lista de assets dispon\u00edveis\n\n\nGest\u00e3o de permiss\u00f5es de escrita por conjunto de organiza\u00e7\u00f5es para cada propriedade do asset\n\n\nGest\u00e3o de private data collections por asset (permiss\u00f5es de leitura)\n\n\nTransa\u00e7\u00f5es de Create/Read/Update/Delete (CRUD) pr\u00e9-definidos\n\n\nCustomiza\u00e7\u00e3o de Transa\u00e7\u00f5es, com defini\u00e7\u00e3o pr\u00e9via de argumentos, m\u00e9todo webservice (GET, POST etc)\n\n\nGest\u00e3o de lista de transa\u00e7\u00f5es dispon\u00edveis.\n\n\nWeb service compat\u00edvel\n\n\nAplica\u00e7\u00e3o web pronta para uso compat\u00edvel",
            "title": "Home"
        },
        {
            "location": "/#introducao",
            "text": "A biblioteca  GoLedger CC-Tools  \u00e9 um esfor\u00e7o colaborativo da empresa GoLedger para fornecer aos desenvolvedores uma biblioteca potente e de f\u00e1cil uso para a cria\u00e7\u00e3o de HLF chaincodes.  Desenvolvida em GoLang, a biblioteca cc-tools possui diversas caracter\u00edsticas que facilitam a jornada de aprendizado, desenvolvimento e deployment em produ\u00e7\u00e3o de um chaincode para Hyperledger Fabric.  A biblioteca CC-Tools est\u00e1 sendo disponibilizada como open-source pela empresa GoLedger para a comunidade de desenvolvimento Hyperledger.",
            "title": "Introdu\u00e7\u00e3o"
        },
        {
            "location": "/#caracteristicas",
            "text": "Mapeamento de dados dos assets (e suas propriedades) padronizado  Encapsulamento das fun\u00e7\u00f5es de interface do sdk de chaincode Hyperledger Fabric   Gest\u00e3o dos asset keys padronizada  Disponibiliza\u00e7\u00e3o de tipos b\u00e1sicos de propriedades dos assets (texto, n\u00famero, booleano, data)  Disponibiliza\u00e7\u00e3o de tipos de listas de tipos b\u00e1sicos de propriedades dos assets (arrays de texto, n\u00famero ou data)  Customiza\u00e7\u00e3o de tipos de propriedades de assets  Gest\u00e3o de assets dentro de assets como refer\u00eancias  Gest\u00e3o de listas de refer\u00eancias de assets  Gest\u00e3o de lista de assets dispon\u00edveis  Gest\u00e3o de permiss\u00f5es de escrita por conjunto de organiza\u00e7\u00f5es para cada propriedade do asset  Gest\u00e3o de private data collections por asset (permiss\u00f5es de leitura)  Transa\u00e7\u00f5es de Create/Read/Update/Delete (CRUD) pr\u00e9-definidos  Customiza\u00e7\u00e3o de Transa\u00e7\u00f5es, com defini\u00e7\u00e3o pr\u00e9via de argumentos, m\u00e9todo webservice (GET, POST etc)  Gest\u00e3o de lista de transa\u00e7\u00f5es dispon\u00edveis.  Web service compat\u00edvel  Aplica\u00e7\u00e3o web pronta para uso compat\u00edvel",
            "title": "Caracter\u00edsticas"
        },
        {
            "location": "/Assets/",
            "text": "Assets\n\n\nOs assets (ou ativos do Blockchain) representam as informa\u00e7\u00f5es que ser\u00e3o utilizadas pelo ledger do Blockchain (\nHyperledger Fabric Channel\n)\n\n\nA grosso modo, um asset pode ser comparado a uma tabela de um banco de dados relacional.\n\n\nE tal como nos bancos dados, os assets s\u00e3o formados por propriedades, sendo que algumas delas podem fazer parte de um conjunto de chaves desse ativo. Cada propriedade pode ter um tipo de dado espec\u00edfico, como string, number, boolean, etc.\n\n\nUm asset tamb\u00e9m pode ser um \nHyperledger Fabric Private Data\n, na qual o conte\u00fado das informa\u00e7\u00f5es s\u00e3o gravados em um bases externas ao channel e apenas um subconjunto das organiza\u00e7\u00f5es recebem esses dados, configurando capacidade de leitura.\n\n\nPara o reposit\u00f3rio cc-tools-demo, 4 assets (sendo que um deles \u00e9 um private data)\n\n\n\n\nPerson\n\n\nBook\n\n\nLibrary\n\n\nSecret (private data)\n\n\n\n\nPara uso da biblioteca GoLedger CC-Tools, a defini\u00e7\u00e3o dos assets \u00e9 feito na pasta \nchaincode/assettypes\n\n\nA seguir est\u00e1 lista de arquivos\n\n\nchaincode/\n    assettypes/     # asset folders\n        person.go   # definition of a person\n        book.go     # definition of a book\n        library.go  # definition of a library\n        secret.go   # definitions of secret (private data)\nassetTypeList.go    # list of assets instantiated\n\n\n\nAsset definition\n\n\nA constru\u00e7\u00e3o e defini\u00e7\u00e3o de um asset se faz com a cria\u00e7\u00e3o de um arquivo dentro da pasta \nchaincode/assettypes\n\n\nUm asset possui os seguintes campos\n\n\n\n\nTag\n: campo string para definir o nome do asset referenciado internamento pelo c\u00f3digo e pela Rest Api. N\u00e3o pode ter espa\u00e7os ou caracteres especiais.\n\n\nLabel\n: campo string para definir o r\u00f3tulo para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.\n\n\nDescription\n: campo string de descri\u00e7\u00e3o do asset para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.\n\n\nProps\n: propriedades do asset. Possui campos proprios.\n\n\nReaders\n: utilizado para definir as organiza\u00e7\u00f5es do private data (precisa de configura\u00e7\u00e3o adicional no arquivo \ncollections.json\n)\n\n\n\n\nProperty definition\n\n\nUm asset possui um conjunto de propriedades (Props) para arquitetar o ativo. \n\n\nUma propriedade possui os seguintes campos:\n\n\n\n\nIsKey\n: idenfitica se a propriedade faz parte das chaves do asset. Campo booleano.\n\n\nRequired\n: identifica se a propriedade \u00e9 obrigat\u00f3ria. Campo booleano.\n\n\nReadOnly\n: identifica se a propriedade n\u00e3o pode mais ser modificada depois de criadas. Campo booleano.\n\n\nDefaultValue\n: valor padr\u00e3o para a propriedade.\n\n\nWriters\n: utilizado para quais organiza\u00e7\u00f5es podem criar ou alterar essa propriedade. Se a propriedade for chave (campo isKey: true) ent\u00e3o todo o asset s\u00f3 pode ser criado ou alterado pela organiza\u00e7\u00e3o. Lista de strings.\n\n\nDataType\n: tipo da propriedade. CC-Tools possui os seguintes tipos padr\u00e3o: \nstring, number, datetime e boolean\n. Tipos customizados podem ser definidos na pasta \nchaincode/datatypes\n.\n\n\nValidade\n: fun\u00e7\u00e3o de validade da propriedade. Sugere-se utilizar apenas para valida\u00e7\u00f5es simples, fun\u00e7\u00f5es mais complexas deve-se utilizar os datatypes customizados.\n\n\n\n\nAsset examples\n\n\nO reposit\u00f3rio cc-tools-demo traz alguns exemplos:\n\n\nchaincode/\n    assettypes/     # asset foldgers\n        person.go   # definition of a person\n        book.go     # definition of a book\n        library.go  # definition of a library\n        secret.go   # definitions of secret (private data)\nassetTypeList.go    # list of assets instantiated\n\n\n\nAl\u00e9m dos arquivos de cada asset, deve-se cadastrar os assets que podem ser utilizadas pela biblioteca \nGoledger CC-Tools\n no arquivo \nassetTypeList.go\n\n\nA defini\u00e7\u00e3o do asset \nPerson\n \u00e9 a seguinte:\n\n\nvar Person = assets.AssetType{\n    Tag:         \"person\",\n    Label:       \"Person\",\n    Description: \"Personal data of someone\",\n\n    Props: []assets.AssetProp{\n        {\n            // Primary key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"id\",\n            Label:    \"CPF (Brazilian ID)\",\n            DataType: \"cpf\",               // Datatypes are identified at datatypes folder\n            Writers:  []string{`org1MSP`}, // This means only org1 can create the asset (others can edit)\n        },\n        {\n            // Mandatory property\n            Required: true,\n            Tag:      \"name\",\n            Label:    \"Asset Name\",\n            DataType: \"string\",\n            // Validate funcion\n            Validate: func(name interface{}) error {\n                nameStr := name.(string)\n                if nameStr == \"\" {\n                    return fmt.Errorf(\"name must be non-empty\")\n                }\n                return nil\n            },\n        },\n        {\n            // Optional property\n            Tag:      \"dateOfBirth\",\n            Label:    \"Date of Birth\",\n            DataType: \"datetime\",\n        },\n        {\n            // Property with default value\n            Tag:          \"heigth\",\n            Label:        \"Person's heigth\",\n            DefaultValue: 0,\n            DataType:     \"number\",\n        },\n    },\n}\n\n\n\nDe acordo com a descri\u00e7\u00e3o, o ativo \nPerson\n tem as seguintes caracter\u00edticas:\n\n\n\n\nChave prim\u00e1ria \ncpf\n (datatype customizado)\n\n\nApenas a \norg1\n pode criar ou alterar a propriedade \ncpf\n e o asset \nPerson\n (porque essa \u00e9 uma chave)\n\n\nPropriedade \nname\n de tipo \nstring\n \u00e9 obrigat\u00f3ria, e possui valida\u00e7\u00e3o autom\u00e1tica para impedir strings vazias (\"\")\n\n\nPropriedade \ndateofBirth\n de tipo \ndatetime\n opcional.\n\n\nPropriedade \nheigth\n de tipo \nnumber\n, com valor padr\u00e3o 0\n\n\n\n\nA defini\u00e7\u00e3o do asset \nBook\n \u00e9 a seguinte:\n\n\nvar Book = assets.AssetType{\n    Tag:         \"book\",\n    Label:       \"Book\",\n    Description: \"\",\n\n    Props: []assets.AssetProp{\n        {\n            // Composite Key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"title\",\n            Label:    \"Book Title\",\n            DataType: \"string\",\n            Writers:  []string{`org2MSP`}, // This means only org2 can create the asset (others can edit)\n        },\n        {\n            // Composite Key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"author\",\n            Label:    \"Book Author\",\n            DataType: \"string\",\n            Writers:  []string{`org2MSP`}, // This means only org2 can create the asset (others can edit)\n        },\n        {\n            /// Reference to another asset\n            Tag:      \"currentTenant\",\n            Label:    \"Current Tenant\",\n            DataType: \"->person\",\n        },\n        {\n            // String list\n            Tag:      \"genres\",\n            Label:    \"Genres\",\n            DataType: \"[]string\",\n        },\n        {\n            // Date property\n            Tag:      \"published\",\n            Label:    \"Publishment Date\",\n            DataType: \"datetime\",\n        },\n    },\n}\n\n\n\nDe acordo com a descri\u00e7\u00e3o, o ativo \nBook\n tem as seguintes caracter\u00edticas:\n\n\n\n\nChave composta  \ntitle\n e \nauthor\n, ambas com tipo \nstring\n\n\nApenas a \norg2\n pode criar ou alterar as propriedades \ntitle\n e \nauthor\n e o asset \nBook\n (porque s\u00e3o chaves)\n\n\nPropriedade \ncurrentTenant\n de tipo \n->person\n o que representa a refer\u00eancia a um asset \nPerson\n\n\nPropriedade \ngenres\n de tipo \n[]string\n que representa um array de strings\n\n\nPropriedade \npublished\n de tipo \ndatetime\n\n\n\n\nA defini\u00e7\u00e3o do asset \nLibrary\n \u00e9 a seguinte:\n\n\nvar Library = assets.AssetType{\n    Tag:         \"library\",\n    Label:       \"Library\",\n    Description: \"Library as a collection of books\",\n\n    Props: []assets.AssetProp{\n        {\n            // Primary Key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"name\",\n            Label:    \"Library Name\",\n            DataType: \"string\",\n            Writers:  []string{`org3MSP`}, // This means only org3 can create the asset (others can edit)\n        },\n        {\n            // Asset reference list\n            Tag:      \"books\",\n            Label:    \"Book Collection\",\n            DataType: \"[]->book\",\n        },\n        {\n            // Asset reference list\n            Tag:      \"entranceCode\",\n            Label:    \"Entrance Code for the Library\",\n            DataType: \"->secret\",\n        },\n    },\n}\n\n\n\nDe acordo com a descri\u00e7\u00e3o, o ativo \nLibrary\n tem as seguintes caracter\u00edticas:\n\n\n\n\nChave prim\u00e1ria \nname\n de tipo \nstring\n\n\nApenas a \norg3\n pode criar ou alterar a propriedade \nname\n e o asset \nLibrary\n (porque \u00e9 chave)\n\n\nPropriedade \nbooks\n de tipo \n[]->book\n o que representa um array de refer\u00eancias ao asset \nBook\n\n\nPropriedade \nentranceCode\n de tipo \n->secret\n que representa a refer\u00eancia a um tipo private data\n\n\n\n\nA defini\u00e7\u00e3o do asset \nSecret\n \u00e9 a seguinte:\n    var Secret = assets.AssetType{\n        Tag:         \"secret\",\n        Label:       \"Secret\",\n        Description: \"Secret between Org2 and Org3\",\n\n\n    Readers: []string{\"org2MSP\", \"org3MSP\"},\n    Props: []assets.AssetProp{\n        {\n            // Primary Key\n            IsKey:    true,\n            Tag:      \"secretName\",\n            Label:    \"Secret Name\",\n            DataType: \"string\",\n            Writers:  []string{`org2MSP`}, // This means only org2 can create the asset (org3 can edit)\n        },\n        {\n            // Mandatory Property\n            Required: true,\n            Tag:      \"secret\",\n            Label:    \"Secret\",\n            DataType: \"string\",\n        },\n    },\n}\n\n\n\nDe acordo com a descri\u00e7\u00e3o, o ativo \nSecret\n tem as caracter\u00edsticas de privacidade (\nHyperledger Fabric Private Data\n). Para esse ativo funcionar corretamenta, deve-se configurar o arquivo \ncollections.json\n\n\nN\u00e3o iremos descrever os conceitos do \nprivate data\n do framework \nHyperledger Fabric\n, seu funcionamento, regras de \npolicy\n, etc. Mas para contextualizar de forma simpl\u00f3ria, quando um ativo \u00e9 definido como private, apenas o hash do seu conte\u00fado fica gravado no \nchannel\n, o conte\u00fado do asset (suas propriedades) apenas s\u00e3o acessados em um conjunto limitado de organiza\u00e7\u00f5es, sendo essas informa\u00e7\u00e3os registradas em bases de dados base de dados transientes em cada peer.\n\n\n\n\nO conte\u00fado do ativo apenas pode ser lido pela \norg2\n e \norg3\n\n\nChave prim\u00e1ria \nsecretName\n de tipo \nstring\n\n\nApenas a \norg2\n pode criar ou alterar a propriedade \nsecretName\n e o asset \nSecret\n (porque \u00e9 chave)\n\n\nPropriedade \nsecret\n de tipo \nstring\n \u00e9 obrigat\u00f3ria para o asset\n\n\nTanto a \norg2\n quanto a \norg3\n pode criar ou alterar a propridade \nsecret\n\n\n\n\nO arquivo \ncollections.json\n precisa ser configurado de acordo com os assets que possuem o campo \nReaders\n\n\n[\n        {\n        \"name\": \"secret\",\n        \"policy\": {\n        \"identities\": [\n            {\n            \"role\": {\n                \"name\": \"member\",\n                \"mspId\": \"org2MSP\"\n            }\n            },\n            {\n            \"role\": {\n                \"name\": \"member\",\n                \"mspId\": \"org3MSP\"\n            }\n            }\n        ],\n        \"policy\": {\n            \"1-of\": [\n            {\n                \"signed-by\": 0\n            },\n            {\n                \"signed-by\": 1\n            }\n            ]\n        }\n        },\n        \"requiredPeerCount\": 0,\n        \"maxPeerCount\": 3,\n        \"blockToLive\": 1000000,\n        \"memberOnlyRead\": true\n    }\n]\n\n\n\nAsset list definition\n\n\nO cadastro dos assets que ser\u00e3o usados pela biblioteca \nGoLedger CC-Tools\n deve ser realizado no arquivo \nchaincode/assetTypeList.go\n\n\nvar assetTypeList = []assets.AssetType{\n    assettypes.Person,\n    assettypes.Book,\n    assettypes.Library,\n    assettypes.Secret,\n}",
            "title": "Assets"
        },
        {
            "location": "/Assets/#assets",
            "text": "Os assets (ou ativos do Blockchain) representam as informa\u00e7\u00f5es que ser\u00e3o utilizadas pelo ledger do Blockchain ( Hyperledger Fabric Channel )  A grosso modo, um asset pode ser comparado a uma tabela de um banco de dados relacional.  E tal como nos bancos dados, os assets s\u00e3o formados por propriedades, sendo que algumas delas podem fazer parte de um conjunto de chaves desse ativo. Cada propriedade pode ter um tipo de dado espec\u00edfico, como string, number, boolean, etc.  Um asset tamb\u00e9m pode ser um  Hyperledger Fabric Private Data , na qual o conte\u00fado das informa\u00e7\u00f5es s\u00e3o gravados em um bases externas ao channel e apenas um subconjunto das organiza\u00e7\u00f5es recebem esses dados, configurando capacidade de leitura.  Para o reposit\u00f3rio cc-tools-demo, 4 assets (sendo que um deles \u00e9 um private data)   Person  Book  Library  Secret (private data)   Para uso da biblioteca GoLedger CC-Tools, a defini\u00e7\u00e3o dos assets \u00e9 feito na pasta  chaincode/assettypes  A seguir est\u00e1 lista de arquivos  chaincode/\n    assettypes/     # asset folders\n        person.go   # definition of a person\n        book.go     # definition of a book\n        library.go  # definition of a library\n        secret.go   # definitions of secret (private data)\nassetTypeList.go    # list of assets instantiated",
            "title": "Assets"
        },
        {
            "location": "/Assets/#asset-definition",
            "text": "A constru\u00e7\u00e3o e defini\u00e7\u00e3o de um asset se faz com a cria\u00e7\u00e3o de um arquivo dentro da pasta  chaincode/assettypes  Um asset possui os seguintes campos   Tag : campo string para definir o nome do asset referenciado internamento pelo c\u00f3digo e pela Rest Api. N\u00e3o pode ter espa\u00e7os ou caracteres especiais.  Label : campo string para definir o r\u00f3tulo para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.  Description : campo string de descri\u00e7\u00e3o do asset para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.  Props : propriedades do asset. Possui campos proprios.  Readers : utilizado para definir as organiza\u00e7\u00f5es do private data (precisa de configura\u00e7\u00e3o adicional no arquivo  collections.json )",
            "title": "Asset definition"
        },
        {
            "location": "/Assets/#property-definition",
            "text": "Um asset possui um conjunto de propriedades (Props) para arquitetar o ativo.   Uma propriedade possui os seguintes campos:   IsKey : idenfitica se a propriedade faz parte das chaves do asset. Campo booleano.  Required : identifica se a propriedade \u00e9 obrigat\u00f3ria. Campo booleano.  ReadOnly : identifica se a propriedade n\u00e3o pode mais ser modificada depois de criadas. Campo booleano.  DefaultValue : valor padr\u00e3o para a propriedade.  Writers : utilizado para quais organiza\u00e7\u00f5es podem criar ou alterar essa propriedade. Se a propriedade for chave (campo isKey: true) ent\u00e3o todo o asset s\u00f3 pode ser criado ou alterado pela organiza\u00e7\u00e3o. Lista de strings.  DataType : tipo da propriedade. CC-Tools possui os seguintes tipos padr\u00e3o:  string, number, datetime e boolean . Tipos customizados podem ser definidos na pasta  chaincode/datatypes .  Validade : fun\u00e7\u00e3o de validade da propriedade. Sugere-se utilizar apenas para valida\u00e7\u00f5es simples, fun\u00e7\u00f5es mais complexas deve-se utilizar os datatypes customizados.",
            "title": "Property definition"
        },
        {
            "location": "/Assets/#asset-examples",
            "text": "O reposit\u00f3rio cc-tools-demo traz alguns exemplos:  chaincode/\n    assettypes/     # asset foldgers\n        person.go   # definition of a person\n        book.go     # definition of a book\n        library.go  # definition of a library\n        secret.go   # definitions of secret (private data)\nassetTypeList.go    # list of assets instantiated  Al\u00e9m dos arquivos de cada asset, deve-se cadastrar os assets que podem ser utilizadas pela biblioteca  Goledger CC-Tools  no arquivo  assetTypeList.go  A defini\u00e7\u00e3o do asset  Person  \u00e9 a seguinte:  var Person = assets.AssetType{\n    Tag:         \"person\",\n    Label:       \"Person\",\n    Description: \"Personal data of someone\",\n\n    Props: []assets.AssetProp{\n        {\n            // Primary key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"id\",\n            Label:    \"CPF (Brazilian ID)\",\n            DataType: \"cpf\",               // Datatypes are identified at datatypes folder\n            Writers:  []string{`org1MSP`}, // This means only org1 can create the asset (others can edit)\n        },\n        {\n            // Mandatory property\n            Required: true,\n            Tag:      \"name\",\n            Label:    \"Asset Name\",\n            DataType: \"string\",\n            // Validate funcion\n            Validate: func(name interface{}) error {\n                nameStr := name.(string)\n                if nameStr == \"\" {\n                    return fmt.Errorf(\"name must be non-empty\")\n                }\n                return nil\n            },\n        },\n        {\n            // Optional property\n            Tag:      \"dateOfBirth\",\n            Label:    \"Date of Birth\",\n            DataType: \"datetime\",\n        },\n        {\n            // Property with default value\n            Tag:          \"heigth\",\n            Label:        \"Person's heigth\",\n            DefaultValue: 0,\n            DataType:     \"number\",\n        },\n    },\n}  De acordo com a descri\u00e7\u00e3o, o ativo  Person  tem as seguintes caracter\u00edticas:   Chave prim\u00e1ria  cpf  (datatype customizado)  Apenas a  org1  pode criar ou alterar a propriedade  cpf  e o asset  Person  (porque essa \u00e9 uma chave)  Propriedade  name  de tipo  string  \u00e9 obrigat\u00f3ria, e possui valida\u00e7\u00e3o autom\u00e1tica para impedir strings vazias (\"\")  Propriedade  dateofBirth  de tipo  datetime  opcional.  Propriedade  heigth  de tipo  number , com valor padr\u00e3o 0   A defini\u00e7\u00e3o do asset  Book  \u00e9 a seguinte:  var Book = assets.AssetType{\n    Tag:         \"book\",\n    Label:       \"Book\",\n    Description: \"\",\n\n    Props: []assets.AssetProp{\n        {\n            // Composite Key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"title\",\n            Label:    \"Book Title\",\n            DataType: \"string\",\n            Writers:  []string{`org2MSP`}, // This means only org2 can create the asset (others can edit)\n        },\n        {\n            // Composite Key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"author\",\n            Label:    \"Book Author\",\n            DataType: \"string\",\n            Writers:  []string{`org2MSP`}, // This means only org2 can create the asset (others can edit)\n        },\n        {\n            /// Reference to another asset\n            Tag:      \"currentTenant\",\n            Label:    \"Current Tenant\",\n            DataType: \"->person\",\n        },\n        {\n            // String list\n            Tag:      \"genres\",\n            Label:    \"Genres\",\n            DataType: \"[]string\",\n        },\n        {\n            // Date property\n            Tag:      \"published\",\n            Label:    \"Publishment Date\",\n            DataType: \"datetime\",\n        },\n    },\n}  De acordo com a descri\u00e7\u00e3o, o ativo  Book  tem as seguintes caracter\u00edticas:   Chave composta   title  e  author , ambas com tipo  string  Apenas a  org2  pode criar ou alterar as propriedades  title  e  author  e o asset  Book  (porque s\u00e3o chaves)  Propriedade  currentTenant  de tipo  ->person  o que representa a refer\u00eancia a um asset  Person  Propriedade  genres  de tipo  []string  que representa um array de strings  Propriedade  published  de tipo  datetime   A defini\u00e7\u00e3o do asset  Library  \u00e9 a seguinte:  var Library = assets.AssetType{\n    Tag:         \"library\",\n    Label:       \"Library\",\n    Description: \"Library as a collection of books\",\n\n    Props: []assets.AssetProp{\n        {\n            // Primary Key\n            Required: true,\n            IsKey:    true,\n            Tag:      \"name\",\n            Label:    \"Library Name\",\n            DataType: \"string\",\n            Writers:  []string{`org3MSP`}, // This means only org3 can create the asset (others can edit)\n        },\n        {\n            // Asset reference list\n            Tag:      \"books\",\n            Label:    \"Book Collection\",\n            DataType: \"[]->book\",\n        },\n        {\n            // Asset reference list\n            Tag:      \"entranceCode\",\n            Label:    \"Entrance Code for the Library\",\n            DataType: \"->secret\",\n        },\n    },\n}  De acordo com a descri\u00e7\u00e3o, o ativo  Library  tem as seguintes caracter\u00edticas:   Chave prim\u00e1ria  name  de tipo  string  Apenas a  org3  pode criar ou alterar a propriedade  name  e o asset  Library  (porque \u00e9 chave)  Propriedade  books  de tipo  []->book  o que representa um array de refer\u00eancias ao asset  Book  Propriedade  entranceCode  de tipo  ->secret  que representa a refer\u00eancia a um tipo private data   A defini\u00e7\u00e3o do asset  Secret  \u00e9 a seguinte:\n    var Secret = assets.AssetType{\n        Tag:         \"secret\",\n        Label:       \"Secret\",\n        Description: \"Secret between Org2 and Org3\",      Readers: []string{\"org2MSP\", \"org3MSP\"},\n    Props: []assets.AssetProp{\n        {\n            // Primary Key\n            IsKey:    true,\n            Tag:      \"secretName\",\n            Label:    \"Secret Name\",\n            DataType: \"string\",\n            Writers:  []string{`org2MSP`}, // This means only org2 can create the asset (org3 can edit)\n        },\n        {\n            // Mandatory Property\n            Required: true,\n            Tag:      \"secret\",\n            Label:    \"Secret\",\n            DataType: \"string\",\n        },\n    },\n}  De acordo com a descri\u00e7\u00e3o, o ativo  Secret  tem as caracter\u00edsticas de privacidade ( Hyperledger Fabric Private Data ). Para esse ativo funcionar corretamenta, deve-se configurar o arquivo  collections.json  N\u00e3o iremos descrever os conceitos do  private data  do framework  Hyperledger Fabric , seu funcionamento, regras de  policy , etc. Mas para contextualizar de forma simpl\u00f3ria, quando um ativo \u00e9 definido como private, apenas o hash do seu conte\u00fado fica gravado no  channel , o conte\u00fado do asset (suas propriedades) apenas s\u00e3o acessados em um conjunto limitado de organiza\u00e7\u00f5es, sendo essas informa\u00e7\u00e3os registradas em bases de dados base de dados transientes em cada peer.   O conte\u00fado do ativo apenas pode ser lido pela  org2  e  org3  Chave prim\u00e1ria  secretName  de tipo  string  Apenas a  org2  pode criar ou alterar a propriedade  secretName  e o asset  Secret  (porque \u00e9 chave)  Propriedade  secret  de tipo  string  \u00e9 obrigat\u00f3ria para o asset  Tanto a  org2  quanto a  org3  pode criar ou alterar a propridade  secret   O arquivo  collections.json  precisa ser configurado de acordo com os assets que possuem o campo  Readers  [\n        {\n        \"name\": \"secret\",\n        \"policy\": {\n        \"identities\": [\n            {\n            \"role\": {\n                \"name\": \"member\",\n                \"mspId\": \"org2MSP\"\n            }\n            },\n            {\n            \"role\": {\n                \"name\": \"member\",\n                \"mspId\": \"org3MSP\"\n            }\n            }\n        ],\n        \"policy\": {\n            \"1-of\": [\n            {\n                \"signed-by\": 0\n            },\n            {\n                \"signed-by\": 1\n            }\n            ]\n        }\n        },\n        \"requiredPeerCount\": 0,\n        \"maxPeerCount\": 3,\n        \"blockToLive\": 1000000,\n        \"memberOnlyRead\": true\n    }\n]",
            "title": "Asset examples"
        },
        {
            "location": "/Assets/#asset-list-definition",
            "text": "O cadastro dos assets que ser\u00e3o usados pela biblioteca  GoLedger CC-Tools  deve ser realizado no arquivo  chaincode/assetTypeList.go  var assetTypeList = []assets.AssetType{\n    assettypes.Person,\n    assettypes.Book,\n    assettypes.Library,\n    assettypes.Secret,\n}",
            "title": "Asset list definition"
        },
        {
            "location": "/External Tools/",
            "text": "External Tools\n\n\nA biblioteca \nGoLedger CC-Tools\n possui uma gama de ferramentas externas que ajudam imensamente na jornada de desenvolvimento de um Blockchain permissionado baseado em \nHyperledger Fabric\n\n\n\n\ncc-tools-demo\n - reposit\u00f3rio p\u00fablico com exemplo de ativos e transa\u00e7\u00f5es utilizando a biblioteca \nGoLedger CC-Tools\n\n\ncc-webclient\n - imagem docker com aplica\u00e7\u00e3o Web para interconex\u00e3o com a Rest Api.\n\n\nGoFabric\n - plataforma de orquestra\u00e7\u00e3o de redes para ambientes de produ\u00e7\u00e3o. \nhttps://gofabric.io\n\n\n\n\ncc-tools-demo\n\n\nReposit\u00f3rio aberto com exemplos e transa\u00e7\u00f5es.\n\n\nO reposit\u00f3rio pode ser acessado da seguinte forma:\n\n\ngit clone https://github.com/goledgerdev/cc-tools-demo.git\n\n\n\n\ncc-web-client\n\n\nImagem docker com aplica\u00e7\u00e3o web para testes e aux\u00edlio de integra\u00e7\u00f5es com sistemas legados.\n\n\nO container pode ser instanciado da seguinte forma:\n\n\ndocker run -p 0.0.0.0:8080:80/tcp --name cc-webclient goledger/cc-webclient:latest\n\n\n\n\nGoFabric\n\n\nGoFabric\n \u00e9 uma plataforma de orquestra\u00e7\u00e3o de redes \nHyperledger Fabric\n totalmente compat\u00edvel com a biblioteca \nGoLedger CC-Tools\n\n\nA plataforma pode ser acessada no seguinte link: \nhttps://gofabric.io\n e possui as seguintes fun\u00e7\u00f5es:\n\n\n\n\nDeployment de redes ambiente de nuvem (\nAWS, IBM, Azure, etc\n) ou \non-premise\n\n\nInstanciar chaincodes (\ncompatibilidade com CC-Tools\n)\n\n\nAtualizar chaincodes\n\n\nAdicionar ou remover \npeers\n\n\nAdicionar \norderers\n\n\nAdicionar \norgs\n\n\nInstanciar ou atualizar \nRest Servers\n\n\nGera\u00e7\u00e3o autom\u00e1tica de c\u00f3digo \nGoLedger Templates",
            "title": "External Tools"
        },
        {
            "location": "/External Tools/#external-tools",
            "text": "A biblioteca  GoLedger CC-Tools  possui uma gama de ferramentas externas que ajudam imensamente na jornada de desenvolvimento de um Blockchain permissionado baseado em  Hyperledger Fabric   cc-tools-demo  - reposit\u00f3rio p\u00fablico com exemplo de ativos e transa\u00e7\u00f5es utilizando a biblioteca  GoLedger CC-Tools  cc-webclient  - imagem docker com aplica\u00e7\u00e3o Web para interconex\u00e3o com a Rest Api.  GoFabric  - plataforma de orquestra\u00e7\u00e3o de redes para ambientes de produ\u00e7\u00e3o.  https://gofabric.io",
            "title": "External Tools"
        },
        {
            "location": "/External Tools/#cc-tools-demo",
            "text": "Reposit\u00f3rio aberto com exemplos e transa\u00e7\u00f5es.  O reposit\u00f3rio pode ser acessado da seguinte forma:  git clone https://github.com/goledgerdev/cc-tools-demo.git",
            "title": "cc-tools-demo"
        },
        {
            "location": "/External Tools/#cc-web-client",
            "text": "Imagem docker com aplica\u00e7\u00e3o web para testes e aux\u00edlio de integra\u00e7\u00f5es com sistemas legados.  O container pode ser instanciado da seguinte forma:  docker run -p 0.0.0.0:8080:80/tcp --name cc-webclient goledger/cc-webclient:latest",
            "title": "cc-web-client"
        },
        {
            "location": "/External Tools/#gofabric",
            "text": "GoFabric  \u00e9 uma plataforma de orquestra\u00e7\u00e3o de redes  Hyperledger Fabric  totalmente compat\u00edvel com a biblioteca  GoLedger CC-Tools  A plataforma pode ser acessada no seguinte link:  https://gofabric.io  e possui as seguintes fun\u00e7\u00f5es:   Deployment de redes ambiente de nuvem ( AWS, IBM, Azure, etc ) ou  on-premise  Instanciar chaincodes ( compatibilidade com CC-Tools )  Atualizar chaincodes  Adicionar ou remover  peers  Adicionar  orderers  Adicionar  orgs  Instanciar ou atualizar  Rest Servers  Gera\u00e7\u00e3o autom\u00e1tica de c\u00f3digo  GoLedger Templates",
            "title": "GoFabric"
        },
        {
            "location": "/Getting Started/",
            "text": "Getting Started\n\n\nO biblioteca GoLedger CC-Tools foi desenvolvida para ser utilizando em sistema operacional Linux.\n\n\nEm geral utilizamos a distribui\u00e7\u00e3 Ubuntu 18+, por\u00e9m a biblioteca \u00e9 compat\u00edvel com outros ambientes, mas alguns ajustes podem ser necess\u00e1rios.\n\n\nDownload demo code\n\n\nPara aprender a utilizar a biblioteca GoLedger CC-Tools baixe o resposit\u00f3rio do c\u00f3digo de demonstra\u00e7\u00e3o dispon\u00edvel no Github.\n\n\ncd $HOME \\\ngit clone https://github.com/goledgerdev/cc-tools-demo.git \\\ncd cc-tools-demo\n\n\n\n\nFolders distribution\n\n\n. { cc-tools-demo root folder }\n|\n\u251c\u2500\u2500 chaincode { Smart contract code (GoLang) }\n|   \u2514\u2500\u2500 assettypes { Asset definitions }\n|   \u2514\u2500\u2500 txdefs { Blockchain transactions }\n|   \u2514\u2500\u2500 datatypes { Custom property datatypes }\n|\n\u251c\u2500\u2500 rest-server { Rest API code (NodeJs) }\n|\n\u251c\u2500\u2500 fabric { Hyperledger Fabric artifacts }\n\n\n\n\nEsse reposit\u00f3rio possui os elementos necess\u00e1rios para utilizar as principais fun\u00e7\u00f5es a biblioteca.\n\n\nEnviroment configuration\n\n\nOs seguintes sistemas, plataformas e linguagens devem estar instaladas:\n\n\n\n\nDocker 19+\n\n\nGCC\n\n\nGoLang 1.14+\n\n\nNodeJs 10+\n\n\nHyperledger Fabric 1.4 (Hyperledger Fabric 2.x ainda em roadmap)\n\n\n\n\nPara Linux Ubuntu, o execute o seguinte comando, que far\u00e1 o download e instala\u00e7\u00e3o dos sistemas acima antes de iniciar o desenvolvimento.\n\n\nO reposit\u00f3rio possui um script de configura\u00e7\u00e3o.\n\n\n./installPreReqUbuntu.sh\n\n\n\n\nAo final da execu\u00e7\u00e3o, deve aparecer a seguinte mensagem de sucesso.\n\n\nEnviroment configured",
            "title": "Getting Started"
        },
        {
            "location": "/Getting Started/#getting-started",
            "text": "O biblioteca GoLedger CC-Tools foi desenvolvida para ser utilizando em sistema operacional Linux.  Em geral utilizamos a distribui\u00e7\u00e3 Ubuntu 18+, por\u00e9m a biblioteca \u00e9 compat\u00edvel com outros ambientes, mas alguns ajustes podem ser necess\u00e1rios.",
            "title": "Getting Started"
        },
        {
            "location": "/Getting Started/#download-demo-code",
            "text": "Para aprender a utilizar a biblioteca GoLedger CC-Tools baixe o resposit\u00f3rio do c\u00f3digo de demonstra\u00e7\u00e3o dispon\u00edvel no Github.  cd $HOME \\\ngit clone https://github.com/goledgerdev/cc-tools-demo.git \\\ncd cc-tools-demo",
            "title": "Download demo code"
        },
        {
            "location": "/Getting Started/#folders-distribution",
            "text": ". { cc-tools-demo root folder }\n|\n\u251c\u2500\u2500 chaincode { Smart contract code (GoLang) }\n|   \u2514\u2500\u2500 assettypes { Asset definitions }\n|   \u2514\u2500\u2500 txdefs { Blockchain transactions }\n|   \u2514\u2500\u2500 datatypes { Custom property datatypes }\n|\n\u251c\u2500\u2500 rest-server { Rest API code (NodeJs) }\n|\n\u251c\u2500\u2500 fabric { Hyperledger Fabric artifacts }  Esse reposit\u00f3rio possui os elementos necess\u00e1rios para utilizar as principais fun\u00e7\u00f5es a biblioteca.",
            "title": "Folders distribution"
        },
        {
            "location": "/Getting Started/#enviroment-configuration",
            "text": "Os seguintes sistemas, plataformas e linguagens devem estar instaladas:   Docker 19+  GCC  GoLang 1.14+  NodeJs 10+  Hyperledger Fabric 1.4 (Hyperledger Fabric 2.x ainda em roadmap)   Para Linux Ubuntu, o execute o seguinte comando, que far\u00e1 o download e instala\u00e7\u00e3o dos sistemas acima antes de iniciar o desenvolvimento.  O reposit\u00f3rio possui um script de configura\u00e7\u00e3o.  ./installPreReqUbuntu.sh  Ao final da execu\u00e7\u00e3o, deve aparecer a seguinte mensagem de sucesso.  Enviroment configured",
            "title": "Enviroment configuration"
        },
        {
            "location": "/Testing/",
            "text": "Testing\n\n\nGoLedger CC-Tools\n possui diferente formas de testar o c\u00f3digo-fonte em desenvolvimento.\n\n\nPara verifica\u00e7\u00e3o de sintaxe da linguagem de programa\u00e7\u00e3o \nGoLang\n sugere o uso do seguinte comando:\n\n\ncd chaincode \\\ngo vet\n\n\n\n\nAp\u00f3s o c\u00f3digo corretamente instanciado ou atualizado, pode-se verificar os logs diretamentes nos containers de execu\u00e7\u00e3o do \nchaincode\n nos \npeers\n. Esses containers podems ser identificados por come\u00e7arem com \ndev\n. \n\n\ndocker logs dev-peer0.org1.example.com-cc-tools-demo-0.1\n\n\n\n\nUsing cc-webclient\n\n\nPara realizar os testes e integra\u00e7\u00f5es de forma satisfat\u00f3rio, sugere-se utilizar a ferramenta \ncc-webclient\n. Terminanda as etapas sugere realizar os seguintes comandos para a cria\u00e7\u00e3o de 3 aplica\u00e7\u00f5es para conectarem com as \norg1, org2 e org3\n.\n\n\n./run-cc-web.sh 8080 & \\\n./run-cc-web.sh 8090 & \\\n./run-cc-web.sh 8100 &\n\n\n\n\nConfiguring rest-server and cc-webclient\n\n\nAp\u00f3s a execu\u00e7\u00e3o dos containers \ncc-webclient\n, as aplica\u00e7\u00f5es podem ser acessadas diretamente pelas portas definidas no script. Ex: 8080, 8090, 8100\n\n\nAp\u00f3s o acesso ao cc-webclient pelo browser, a configura\u00e7\u00e3o para acesso ao Rest server, pode ser feito clicando no \u00edcone de ferramenta.\n\n\n\n\nOs acessos s\u00e3o feitos com as seguintes configura\u00e7\u00f5es:\n\n\n\n\norg1\n: \nhttp://localhost:80\n\n\norg2\n: \nhttp://localhost:980\n\n\norg3\n: \nhttp://localhost:1080\n\n\n\n\n\n\nA aplica\u00e7\u00e3o \ncc-webclient\n possui uma barra lateral para mostrar os \nassets\n dispon\u00edveis assim como as \ntransactions\n cadastradas no chaincode.\n\n\n\n\nEndpoint usage\n\n\nA utiliza\u00e7\u00e3o do Rest server \u00e9 descrita atrav\u00e9s os bot\u00f5es \nCURL\n. \n\n\n\n\nPara cada tela, pode-se verificar uma chamada utilizando a aplica\u00e7\u00e3o \ncurl\n. \n\n\nPor exemplo, na tela de cria\u00e7\u00e3o de ativo:\n\n\n\n\nList, create, edit, delete or history an asset\n\n\nPara \nlistar\n, basta selecionar um asset na barra lateral\n\n\n\n\nSelecionando o bot\u00e3o \nCREATE\n na janela de listagem de um asset, uma tela de \ncria\u00e7\u00e3o\n de ativo vai aparecer.\n\n\nPor exemplo, para o asset \nPerson\n\n\n\n\nA tela de \nedi\u00e7\u00e3o\n \u00e9 acessada selecionando o \u00edcone de editar na janela de listagem de um asset.\n\n\nA \ndele\u00e7\u00e3o\n de um asset \u00e9 requisitada selecionando o \u00edcone de apagar na janela de listagem de um asset.\n\n\nO \nhist\u00f3rico\n de um asset (todas as modifica\u00e7\u00f5es registradas no ledger) pode ser visualizada selecionando o \u00edcone de hist\u00f3rico na janela de um asset.\n\n\nExecuting an transaction\n\n\nA execu\u00e7\u00e3o de uma \ntransa\u00e7\u00e3o\n pode ser realizada selecionando a transa\u00e7\u00e3o na aba lateral.\n\n\nPor exemplo, para a transa\u00e7\u00e3o \nUpdateBookTenant",
            "title": "Testing"
        },
        {
            "location": "/Testing/#testing",
            "text": "GoLedger CC-Tools  possui diferente formas de testar o c\u00f3digo-fonte em desenvolvimento.  Para verifica\u00e7\u00e3o de sintaxe da linguagem de programa\u00e7\u00e3o  GoLang  sugere o uso do seguinte comando:  cd chaincode \\\ngo vet  Ap\u00f3s o c\u00f3digo corretamente instanciado ou atualizado, pode-se verificar os logs diretamentes nos containers de execu\u00e7\u00e3o do  chaincode  nos  peers . Esses containers podems ser identificados por come\u00e7arem com  dev .   docker logs dev-peer0.org1.example.com-cc-tools-demo-0.1",
            "title": "Testing"
        },
        {
            "location": "/Testing/#using-cc-webclient",
            "text": "Para realizar os testes e integra\u00e7\u00f5es de forma satisfat\u00f3rio, sugere-se utilizar a ferramenta  cc-webclient . Terminanda as etapas sugere realizar os seguintes comandos para a cria\u00e7\u00e3o de 3 aplica\u00e7\u00f5es para conectarem com as  org1, org2 e org3 .  ./run-cc-web.sh 8080 & \\\n./run-cc-web.sh 8090 & \\\n./run-cc-web.sh 8100 &",
            "title": "Using cc-webclient"
        },
        {
            "location": "/Testing/#configuring-rest-server-and-cc-webclient",
            "text": "Ap\u00f3s a execu\u00e7\u00e3o dos containers  cc-webclient , as aplica\u00e7\u00f5es podem ser acessadas diretamente pelas portas definidas no script. Ex: 8080, 8090, 8100  Ap\u00f3s o acesso ao cc-webclient pelo browser, a configura\u00e7\u00e3o para acesso ao Rest server, pode ser feito clicando no \u00edcone de ferramenta.   Os acessos s\u00e3o feitos com as seguintes configura\u00e7\u00f5es:   org1 :  http://localhost:80  org2 :  http://localhost:980  org3 :  http://localhost:1080    A aplica\u00e7\u00e3o  cc-webclient  possui uma barra lateral para mostrar os  assets  dispon\u00edveis assim como as  transactions  cadastradas no chaincode.",
            "title": "Configuring rest-server and cc-webclient"
        },
        {
            "location": "/Testing/#endpoint-usage",
            "text": "A utiliza\u00e7\u00e3o do Rest server \u00e9 descrita atrav\u00e9s os bot\u00f5es  CURL .    Para cada tela, pode-se verificar uma chamada utilizando a aplica\u00e7\u00e3o  curl .   Por exemplo, na tela de cria\u00e7\u00e3o de ativo:",
            "title": "Endpoint usage"
        },
        {
            "location": "/Testing/#list-create-edit-delete-or-history-an-asset",
            "text": "Para  listar , basta selecionar um asset na barra lateral   Selecionando o bot\u00e3o  CREATE  na janela de listagem de um asset, uma tela de  cria\u00e7\u00e3o  de ativo vai aparecer.  Por exemplo, para o asset  Person   A tela de  edi\u00e7\u00e3o  \u00e9 acessada selecionando o \u00edcone de editar na janela de listagem de um asset.  A  dele\u00e7\u00e3o  de um asset \u00e9 requisitada selecionando o \u00edcone de apagar na janela de listagem de um asset.  O  hist\u00f3rico  de um asset (todas as modifica\u00e7\u00f5es registradas no ledger) pode ser visualizada selecionando o \u00edcone de hist\u00f3rico na janela de um asset.",
            "title": "List, create, edit, delete or history an asset"
        },
        {
            "location": "/Testing/#executing-an-transaction",
            "text": "A execu\u00e7\u00e3o de uma  transa\u00e7\u00e3o  pode ser realizada selecionando a transa\u00e7\u00e3o na aba lateral.  Por exemplo, para a transa\u00e7\u00e3o  UpdateBookTenant",
            "title": "Executing an transaction"
        },
        {
            "location": "/Transactions/",
            "text": "Transactions\n\n\nAs transa\u00e7\u00f5es dentro da biblioteca \nGoLedger CC-Tools\n representam os m\u00e9todos em \nGoLang\n que podem modificar os ativos dentro do ledger do Blockchain (\nHyperledger Fabric Channel\n)\n\n\nNo \nHyperledger Fabric\n os assets apenas podems ser criados ou modificados atrav\u00e9s da execu\u00e7\u00e3o de transa\u00e7\u00f5es dos \nchaincode\n\n\nA biblioteca \nGoledger CC-Tools\n possui um gama de transa\u00e7\u00f5es pr\u00e9-definidas:\n\n\n\n\nCreateAsset\n- cria\u00e7\u00e3o de um novo asset\n\n\nUpdateAsset\n - atualiza\u00e7\u00e3o de um asset existente\n\n\nDeleteAsset\n - remo\u00e7\u00e3o de um asset do estado atual do ledger\n\n\nReadAsset\n - leitura do asset no seu \u00faltimo estado no ledger\n\n\nReadAssetHistory\n - hist\u00f3rico dos estados de um asset no ledger\n\n\nSearch\n - listagem de assets\n\n\n\n\nA biblioteca \nGoLedger CC-Tools\n possibilita a cria\u00e7\u00e3o de transa\u00e7\u00f5es customizadas.\n\n\nNo reposit\u00f3rio \ncc-tools-demo\n existem 3 transa\u00e7\u00f5es de exemplo:\n\n\n\n\nCreateNewLibrary\n - criar um novo asset do tipo \nLibrary\n\n\nGetNumberOfBooksFromLibrary\n - retorna o n\u00famero de assets \nBook\n \n\n\nUpdateBookTenant\n - atualizar o campo \ncurrentTenant\n no asset \nBook\n\n\n\n\nPara uso da biblioteca GoLedger CC-Tools, a defini\u00e7\u00e3o dos assets \u00e9 feito na pasta \nchaincode/txdefs\n\n\nA seguir est\u00e1 lista de arquivos da pasta \ntxdefs\n:\n\n\nchaincode/\n    txdefs/                             # transations folder\n        createNewLibrary.go             # library creation\n        getNumberOfBooksFromLibrary.go  # returns the number of books at the library asset\n        updateBookTenant.go             # changes de tenant of book\ntxList.go                               # list of custom transactions\n\n\n\nTransaction definition\n\n\nA constru\u00e7\u00e3o e defini\u00e7\u00e3o de uma transa\u00e7\u00e3o customizada se faz com a cria\u00e7\u00e3o de um arquivo dentro da pasta \nchaincode/txdefs\n\n\nUm asset possui os seguintes campos:\n\n\n\n\nTag\n: campo string para definir o nome da transa\u00e7\u00e3o referenciado internamente pelo c\u00f3digo e pela Rest Api. N\u00e3o pode ter espa\u00e7os ou caracteres especiais. Caso tenha o mesmo nome de alguma transa\u00e7\u00e3o pr\u00e9-definida (\ncreateAsset\n, \nupdateAsset\n, \ndeleteAsset\n, \nreadAsset\n, \nreadAssetHistory\n ou \nsearch\n), essa transa\u00e7\u00e3o ser\u00e1 substitu\u00edda pela presente no diret\u00f3ro \ntxdefs\n.\n\n\nLabel\n: campo string para definir o r\u00f3tulo para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.\n\n\nDescription\n: campo string de descri\u00e7\u00e3o do asset para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.\n\n\nMethod\n: tipo de m\u00e9todo da Rest Api. Pode ser \nPOST\n, \nGET\n.\n\n\nCallers\n: utilizado para definir quais as organiza\u00e7\u00f5es podem chamar essa transa\u00e7\u00e3o.\n\n\nArgs\n: argumentos. Possui campos proprios.\n\n\nRoutine\n: codigo-fonte da transa\u00e7\u00e3o.\n\n\n\n\nTransaction argument definition\n\n\nUma transa\u00e7\u00e3o possui um conjunto de arguments de entrada customiz\u00e1veis.\n\n\nUm argumento possui os seguintes campos:\n\n\n\n\nTag\n: campo string para definir o nome do argumento referenciado internamente pelo c\u00f3digo e pela Rest Api. N\u00e3o pode ter espa\u00e7os ou caracteres especiais. \n\n\nLabel\n: campo string para definir o r\u00f3tulo para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.\n\n\nDescription\n: campo string de descri\u00e7\u00e3o do asset para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.\n\n\nRequired\n: identifica se o argumento \u00e9 obrigat\u00f3rio. Campo booleano.\n\n\nDataType\n: tipo da propriedade. CC-Tools possui os seguintes tipos padr\u00e3o: \nstring, number, datetime e boolean\n.\n\n\n\n\nTransaction examples\n\n\nO reposit\u00f3rio \ncc-tools-demo\n traz a seguinte configura\u00e7\u00e3o de transa\u00e7\u00f5es customizadas:\n\n\nchaincode/\n    txdefs/                             # transations folder\n        createNewLibrary.go             # library creation\n        getNumberOfBooksFromLibrary.go  # returns the number of books at the library asset\n        updateBookTenant.go             # changes de tenant of book\ntxList.go                               # list of custom transactions\n\n\n\nAl\u00e9m dos arquivos de cada transa\u00e7\u00e3o, deve-se cadastrar as transa\u00e7\u00f5es que podem ser utilizadas pela biblioteca \nGoledger CC-Tools\n no arquivo \ntxList.go\n\n\nA defini\u00e7\u00e3o da transa\u00e7\u00e3o \nCreateNewLibrary\n \u00e9 a seguinte:\n\n\nvar CreateNewLibrary = tx.Transaction{\n    Tag:         \"createNewLibrary\",\n    Label:       \"Create New Library\",\n    Description: \"Create a New Library\",\n    Method:      \"POST\",\n    Callers:     []string{\"$org3MSP\"}, // Only org3 can call this transaction\n\n    Args: []tx.Argument{\n        {\n            Tag:         \"name\",\n            Label:       \"Name\",\n            Description: \"Name of the library\",\n            DataType:    \"string\",\n            Required:    true,\n        },\n    },\n    Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) {\n        name, ok := req[\"name\"].(string)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter name must be string\")\n        }\n\n        libraryMap := make(map[string]interface{})\n        libraryMap[\"@assetType\"] = \"library\"\n        libraryMap[\"name\"] = name\n\n        libraryAsset, err := assets.NewAsset(libraryMap)\n        if err != nil {\n            return nil, errors.WrapError(err, \"Failed to create a new asset\")\n        }\n\n        // Save the new library on channel\n        _, err = libraryAsset.PutNew(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"Error saving asset on blockchain\")\n        }\n\n        // Marshal asset back to JSON format\n        libraryJSON, nerr := json.Marshal(libraryAsset)\n        if nerr != nil {\n            return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\")\n        }\n\n        return libraryJSON, nil\n    },\n}\n\n\n\nDe acordo com a descri\u00e7\u00e3o, a transa\u00e7\u00e3o \nCreateNewLibrary\n tem as seguintes caracter\u00edticas:\n\n\n\n\nApenas a \norg3\n pode chamar esse m\u00e9todo\n\n\nM\u00e9todo \nPOST\n para a Rest Api\n\n\nArgumento \nname\n de tipo \nstring\n obrigat\u00f3rio.\n\n\nA transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o \nNewAsset\n para prepara um novo asset (chaves, etc) e a fun\u00e7\u00e3o \nPutNew\n para criar o asset no \nchannel\n.\n\n\n\n\nA defini\u00e7\u00e3o da transa\u00e7\u00e3o \nUpdateBookTenant\n \u00e9 a seguinte:\n\n\nvar UpdateBookTenant = tx.Transaction{\n    Tag:         \"updateBookTenant\",\n    Label:       \"Update Book Tenant\",\n    Description: \"Change the tenant of a book\",\n    Method:      \"PUT\",\n    Callers:     []string{`$org\\dMSP`}, // Any orgs can call this transaction\n\n    Args: []tx.Argument{\n        {\n            Tag:         \"book\",\n            Label:       \"Book\",\n            Description: \"Book\",\n            DataType:    \"book\",\n            Required:    true,\n        },\n        {\n            Tag:         \"tenant\",\n            Label:       \"tenant\",\n            Description: \"New tenant of the book\",\n            DataType:    \"person\",\n        },\n    },\n    Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) {\n        bookKey, ok := req[\"book\"].(assets.Key)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter book must be an asset\")\n        }\n        tenantKey, ok := req[\"tenant\"].(assets.Key)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter tenant must be an asset\")\n        }\n\n        // Returns Book from channel\n        bookAsset, err := bookKey.Get(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"failed to get asset from the ledger\")\n        }\n        bookMap := (map[string]interface{})(*bookAsset)\n        if bookMap[\"@assetType\"].(string) != \"book\" {\n            return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\")\n        }\n\n        // Returns person from channel\n        tenantAsset, err := tenantKey.Get(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"failed to get asset from the ledger\")\n        }\n        tenantMap := (map[string]interface{})(*tenantAsset)\n        if tenantMap[\"@assetType\"].(string) != \"person\" {\n            return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\")\n        }\n\n        // Update data\n        bookMap[\"tenant\"] = tenantMap\n\n        bookMap, nerr := bookAsset.Update(stub, bookMap)\n        if nerr != nil {\n            return nil, errors.WrapError(err, \"failed to update asset\")\n        }\n\n        // Marshal asset back to JSON format\n        bookJSON, nerr := json.Marshal(bookAsset)\n        if nerr != nil {\n            return nil, errors.WrapError(err, \"failed to marshal response\")\n        }\n\n        return bookJSON, nil\n    },\n}\n\n\n\n\n\nQualquer organiza\u00e7\u00e3o que comece com \n\"org\"\n seguida de um n\u00famero (org1, org2, org3, org4, etc) pode chamar esse m\u00e9todo.\n\n\nM\u00e9todo \nPUT\n para a Rest Api\n\n\nArgumento \nbook\n de tipo \nBook\n obrigat\u00f3rio.\n\n\nArgumento \nperson\n de tipo \nPerson\n obrigat\u00f3rio.\n\n\nA transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o \nGet\n para ler as informa\u00e7\u00f5es dos assets \nBook\n e \nPerson\n do ledger\n\n\nA transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o \nUpdate\n atualiza as informa\u00e7\u00e3o do asset \nBook\n no ledger\n\n\n\n\nA defini\u00e7\u00e3o da transa\u00e7\u00e3o \nGetNumberOfBooksFromLibrary\n \u00e9 a seguinte:\n\n\nvar GetNumberOfBooksFromLibrary = tx.Transaction{\n    Tag:         \"getNumberOfBooksFromLibrary\",\n    Label:       \"Get Number Of Books From Library\",\n    Description: \"Return the number of books of a library\",\n    Method:      \"GET\",\n    Callers:     []string{\"$org2MSP\"}, // Only org2 can call this transactions\n\n    Args: []tx.Argument{\n        {\n            Tag:         \"library\",\n            Label:       \"Library\",\n            Description: \"Library\",\n            DataType:    \"library\",\n            Required:    true,\n        },\n    },\n    Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) {\n        libraryKey, ok := req[\"library\"].(assets.Key)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter library must be an asset\")\n        }\n\n        // Returns Library from channel\n        libraryAsset, err := libraryKey.Get(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"failed to get asset from the ledger\")\n        }\n        libraryMap := (map[string]interface{})(*libraryAsset)\n        if libraryMap[\"@assetType\"].(string) != \"library\" {\n            return nil, errors.WrapError(err, \"failed to get library from the ledger\")\n        }\n\n        numberOfBooks := 0\n        books, ok := libraryMap[\"books\"].([]interface{})\n        if ok {\n            numberOfBooks = len(books)\n        }\n\n        var returnMap map[string]interface{}\n        returnMap[\"numberOfBooks\"] = numberOfBooks\n\n        // Marshal asset back to JSON format\n        returnJSON, nerr := json.Marshal(returnMap)\n        if nerr != nil {\n            return nil, errors.WrapError(err, \"failed to marshal response\")\n        }\n\n        return returnJSON, nil\n    },\n}\n\n\n\n\n\nApenas a \norg2\n pode chamar esse m\u00e9todo.\n\n\nM\u00e9todo \nGET\n para a Rest Api\n\n\nArgumento \nlibrary\n de tipo \nLibrary\n obrigat\u00f3rio.\n\n\nA transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o \nGet\n para ler as informa\u00e7\u00f5es do asset \nLibrary\n do ledger\n\n\n\n\nTransaction list definition\n\n\nO cadastro das transa\u00e7\u00f5es que ser\u00e3o usados pela biblioteca \nGoLedger CC-Tools\n deve ser realizado no arquivo \nchaincode/txList.go\n\n\nvar txList = []tx.Transaction{\n    txdefs.GetHeader,\n    txdefs.CreateNewLibrary,\n    txdefs.GetNumberOfBooksFromLibrary,\n    txdefs.UpdateBookTenant,\n}",
            "title": "Transactions"
        },
        {
            "location": "/Transactions/#transactions",
            "text": "As transa\u00e7\u00f5es dentro da biblioteca  GoLedger CC-Tools  representam os m\u00e9todos em  GoLang  que podem modificar os ativos dentro do ledger do Blockchain ( Hyperledger Fabric Channel )  No  Hyperledger Fabric  os assets apenas podems ser criados ou modificados atrav\u00e9s da execu\u00e7\u00e3o de transa\u00e7\u00f5es dos  chaincode  A biblioteca  Goledger CC-Tools  possui um gama de transa\u00e7\u00f5es pr\u00e9-definidas:   CreateAsset - cria\u00e7\u00e3o de um novo asset  UpdateAsset  - atualiza\u00e7\u00e3o de um asset existente  DeleteAsset  - remo\u00e7\u00e3o de um asset do estado atual do ledger  ReadAsset  - leitura do asset no seu \u00faltimo estado no ledger  ReadAssetHistory  - hist\u00f3rico dos estados de um asset no ledger  Search  - listagem de assets   A biblioteca  GoLedger CC-Tools  possibilita a cria\u00e7\u00e3o de transa\u00e7\u00f5es customizadas.  No reposit\u00f3rio  cc-tools-demo  existem 3 transa\u00e7\u00f5es de exemplo:   CreateNewLibrary  - criar um novo asset do tipo  Library  GetNumberOfBooksFromLibrary  - retorna o n\u00famero de assets  Book    UpdateBookTenant  - atualizar o campo  currentTenant  no asset  Book   Para uso da biblioteca GoLedger CC-Tools, a defini\u00e7\u00e3o dos assets \u00e9 feito na pasta  chaincode/txdefs  A seguir est\u00e1 lista de arquivos da pasta  txdefs :  chaincode/\n    txdefs/                             # transations folder\n        createNewLibrary.go             # library creation\n        getNumberOfBooksFromLibrary.go  # returns the number of books at the library asset\n        updateBookTenant.go             # changes de tenant of book\ntxList.go                               # list of custom transactions",
            "title": "Transactions"
        },
        {
            "location": "/Transactions/#transaction-definition",
            "text": "A constru\u00e7\u00e3o e defini\u00e7\u00e3o de uma transa\u00e7\u00e3o customizada se faz com a cria\u00e7\u00e3o de um arquivo dentro da pasta  chaincode/txdefs  Um asset possui os seguintes campos:   Tag : campo string para definir o nome da transa\u00e7\u00e3o referenciado internamente pelo c\u00f3digo e pela Rest Api. N\u00e3o pode ter espa\u00e7os ou caracteres especiais. Caso tenha o mesmo nome de alguma transa\u00e7\u00e3o pr\u00e9-definida ( createAsset ,  updateAsset ,  deleteAsset ,  readAsset ,  readAssetHistory  ou  search ), essa transa\u00e7\u00e3o ser\u00e1 substitu\u00edda pela presente no diret\u00f3ro  txdefs .  Label : campo string para definir o r\u00f3tulo para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.  Description : campo string de descri\u00e7\u00e3o do asset para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.  Method : tipo de m\u00e9todo da Rest Api. Pode ser  POST ,  GET .  Callers : utilizado para definir quais as organiza\u00e7\u00f5es podem chamar essa transa\u00e7\u00e3o.  Args : argumentos. Possui campos proprios.  Routine : codigo-fonte da transa\u00e7\u00e3o.",
            "title": "Transaction definition"
        },
        {
            "location": "/Transactions/#transaction-argument-definition",
            "text": "Uma transa\u00e7\u00e3o possui um conjunto de arguments de entrada customiz\u00e1veis.  Um argumento possui os seguintes campos:   Tag : campo string para definir o nome do argumento referenciado internamente pelo c\u00f3digo e pela Rest Api. N\u00e3o pode ter espa\u00e7os ou caracteres especiais.   Label : campo string para definir o r\u00f3tulo para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.  Description : campo string de descri\u00e7\u00e3o do asset para ser utilizado nas aplica\u00e7\u00f5es externas. Texto livre.  Required : identifica se o argumento \u00e9 obrigat\u00f3rio. Campo booleano.  DataType : tipo da propriedade. CC-Tools possui os seguintes tipos padr\u00e3o:  string, number, datetime e boolean .",
            "title": "Transaction argument definition"
        },
        {
            "location": "/Transactions/#transaction-examples",
            "text": "O reposit\u00f3rio  cc-tools-demo  traz a seguinte configura\u00e7\u00e3o de transa\u00e7\u00f5es customizadas:  chaincode/\n    txdefs/                             # transations folder\n        createNewLibrary.go             # library creation\n        getNumberOfBooksFromLibrary.go  # returns the number of books at the library asset\n        updateBookTenant.go             # changes de tenant of book\ntxList.go                               # list of custom transactions  Al\u00e9m dos arquivos de cada transa\u00e7\u00e3o, deve-se cadastrar as transa\u00e7\u00f5es que podem ser utilizadas pela biblioteca  Goledger CC-Tools  no arquivo  txList.go  A defini\u00e7\u00e3o da transa\u00e7\u00e3o  CreateNewLibrary  \u00e9 a seguinte:  var CreateNewLibrary = tx.Transaction{\n    Tag:         \"createNewLibrary\",\n    Label:       \"Create New Library\",\n    Description: \"Create a New Library\",\n    Method:      \"POST\",\n    Callers:     []string{\"$org3MSP\"}, // Only org3 can call this transaction\n\n    Args: []tx.Argument{\n        {\n            Tag:         \"name\",\n            Label:       \"Name\",\n            Description: \"Name of the library\",\n            DataType:    \"string\",\n            Required:    true,\n        },\n    },\n    Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) {\n        name, ok := req[\"name\"].(string)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter name must be string\")\n        }\n\n        libraryMap := make(map[string]interface{})\n        libraryMap[\"@assetType\"] = \"library\"\n        libraryMap[\"name\"] = name\n\n        libraryAsset, err := assets.NewAsset(libraryMap)\n        if err != nil {\n            return nil, errors.WrapError(err, \"Failed to create a new asset\")\n        }\n\n        // Save the new library on channel\n        _, err = libraryAsset.PutNew(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"Error saving asset on blockchain\")\n        }\n\n        // Marshal asset back to JSON format\n        libraryJSON, nerr := json.Marshal(libraryAsset)\n        if nerr != nil {\n            return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\")\n        }\n\n        return libraryJSON, nil\n    },\n}  De acordo com a descri\u00e7\u00e3o, a transa\u00e7\u00e3o  CreateNewLibrary  tem as seguintes caracter\u00edticas:   Apenas a  org3  pode chamar esse m\u00e9todo  M\u00e9todo  POST  para a Rest Api  Argumento  name  de tipo  string  obrigat\u00f3rio.  A transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o  NewAsset  para prepara um novo asset (chaves, etc) e a fun\u00e7\u00e3o  PutNew  para criar o asset no  channel .   A defini\u00e7\u00e3o da transa\u00e7\u00e3o  UpdateBookTenant  \u00e9 a seguinte:  var UpdateBookTenant = tx.Transaction{\n    Tag:         \"updateBookTenant\",\n    Label:       \"Update Book Tenant\",\n    Description: \"Change the tenant of a book\",\n    Method:      \"PUT\",\n    Callers:     []string{`$org\\dMSP`}, // Any orgs can call this transaction\n\n    Args: []tx.Argument{\n        {\n            Tag:         \"book\",\n            Label:       \"Book\",\n            Description: \"Book\",\n            DataType:    \"book\",\n            Required:    true,\n        },\n        {\n            Tag:         \"tenant\",\n            Label:       \"tenant\",\n            Description: \"New tenant of the book\",\n            DataType:    \"person\",\n        },\n    },\n    Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) {\n        bookKey, ok := req[\"book\"].(assets.Key)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter book must be an asset\")\n        }\n        tenantKey, ok := req[\"tenant\"].(assets.Key)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter tenant must be an asset\")\n        }\n\n        // Returns Book from channel\n        bookAsset, err := bookKey.Get(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"failed to get asset from the ledger\")\n        }\n        bookMap := (map[string]interface{})(*bookAsset)\n        if bookMap[\"@assetType\"].(string) != \"book\" {\n            return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\")\n        }\n\n        // Returns person from channel\n        tenantAsset, err := tenantKey.Get(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"failed to get asset from the ledger\")\n        }\n        tenantMap := (map[string]interface{})(*tenantAsset)\n        if tenantMap[\"@assetType\"].(string) != \"person\" {\n            return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\")\n        }\n\n        // Update data\n        bookMap[\"tenant\"] = tenantMap\n\n        bookMap, nerr := bookAsset.Update(stub, bookMap)\n        if nerr != nil {\n            return nil, errors.WrapError(err, \"failed to update asset\")\n        }\n\n        // Marshal asset back to JSON format\n        bookJSON, nerr := json.Marshal(bookAsset)\n        if nerr != nil {\n            return nil, errors.WrapError(err, \"failed to marshal response\")\n        }\n\n        return bookJSON, nil\n    },\n}   Qualquer organiza\u00e7\u00e3o que comece com  \"org\"  seguida de um n\u00famero (org1, org2, org3, org4, etc) pode chamar esse m\u00e9todo.  M\u00e9todo  PUT  para a Rest Api  Argumento  book  de tipo  Book  obrigat\u00f3rio.  Argumento  person  de tipo  Person  obrigat\u00f3rio.  A transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o  Get  para ler as informa\u00e7\u00f5es dos assets  Book  e  Person  do ledger  A transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o  Update  atualiza as informa\u00e7\u00e3o do asset  Book  no ledger   A defini\u00e7\u00e3o da transa\u00e7\u00e3o  GetNumberOfBooksFromLibrary  \u00e9 a seguinte:  var GetNumberOfBooksFromLibrary = tx.Transaction{\n    Tag:         \"getNumberOfBooksFromLibrary\",\n    Label:       \"Get Number Of Books From Library\",\n    Description: \"Return the number of books of a library\",\n    Method:      \"GET\",\n    Callers:     []string{\"$org2MSP\"}, // Only org2 can call this transactions\n\n    Args: []tx.Argument{\n        {\n            Tag:         \"library\",\n            Label:       \"Library\",\n            Description: \"Library\",\n            DataType:    \"library\",\n            Required:    true,\n        },\n    },\n    Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) {\n        libraryKey, ok := req[\"library\"].(assets.Key)\n        if !ok {\n            return nil, errors.WrapError(nil, \"Parameter library must be an asset\")\n        }\n\n        // Returns Library from channel\n        libraryAsset, err := libraryKey.Get(stub)\n        if err != nil {\n            return nil, errors.WrapError(err, \"failed to get asset from the ledger\")\n        }\n        libraryMap := (map[string]interface{})(*libraryAsset)\n        if libraryMap[\"@assetType\"].(string) != \"library\" {\n            return nil, errors.WrapError(err, \"failed to get library from the ledger\")\n        }\n\n        numberOfBooks := 0\n        books, ok := libraryMap[\"books\"].([]interface{})\n        if ok {\n            numberOfBooks = len(books)\n        }\n\n        var returnMap map[string]interface{}\n        returnMap[\"numberOfBooks\"] = numberOfBooks\n\n        // Marshal asset back to JSON format\n        returnJSON, nerr := json.Marshal(returnMap)\n        if nerr != nil {\n            return nil, errors.WrapError(err, \"failed to marshal response\")\n        }\n\n        return returnJSON, nil\n    },\n}   Apenas a  org2  pode chamar esse m\u00e9todo.  M\u00e9todo  GET  para a Rest Api  Argumento  library  de tipo  Library  obrigat\u00f3rio.  A transa\u00e7\u00e3o utiliza a fun\u00e7\u00e3o  Get  para ler as informa\u00e7\u00f5es do asset  Library  do ledger",
            "title": "Transaction examples"
        },
        {
            "location": "/Transactions/#transaction-list-definition",
            "text": "O cadastro das transa\u00e7\u00f5es que ser\u00e3o usados pela biblioteca  GoLedger CC-Tools  deve ser realizado no arquivo  chaincode/txList.go  var txList = []tx.Transaction{\n    txdefs.GetHeader,\n    txdefs.CreateNewLibrary,\n    txdefs.GetNumberOfBooksFromLibrary,\n    txdefs.UpdateBookTenant,\n}",
            "title": "Transaction list definition"
        },
        {
            "location": "/Tutorial/",
            "text": "Writing Your First Application\n\n\nNeste tutorial, iremos instalar e utilizar um contrato inteligente (chaincode).\n\n\n\u00c9 necess\u00e1rio estar com o ambiente configurado para poder realizar esse tutorial. Detalhes em \nGetting Started\n\n\nVeremos como a biblioteca GoLedger CC-Tools funciona, utilizando os artefatos disponibilizados pela GoLedger\n\n\n\n\nRest-server integrada\n\n\nApi de atualiza\u00e7\u00e3o Hyperledger Fabric\n\n\nAplica\u00e7\u00e3o Web de desenvolvimento (cc-web)\n\n\n\n\nO contrato inteligente do resposit\u00f3rio cc-tool-demo \u00e9 ideal para os iniciantes ao desenvolvimento na tecnologia Hyperledger Fabric. \u00c9 um \u00f3timo ponto de partida para entender uma blockchain do Hyperledger Fabric e facilitar a jornada para o deenvolvimento de aplica\u00e7\u00f5es utilizando esse framework. \n\n\nVoc\u00ea aprender\u00e1 como escrever um aplicativo e um contrato inteligente (chaincode) para consultar e atualizar um livro raz\u00e3o, e como se conectar com o Blockchain atrav\u00e9s de uma API pronta para uso.\n\n\n\n\nNOTE\n\n\n\u00c9 necess\u00e1rio conhecer a linguagem de programa\u00e7\u00e3o \nGoLang\n para realizar esse tutorial.\n\n\n\n\nNetwork Details\n\n\nA rede a ser criada ter\u00e1 a seguinte configura\u00e7\u00e3o:\n\n\n\n\n1 chaincode (cc-tools-demo)\n\n\n3 orgs (org1, org2, org3)\n\n\n3 clients (rest-server para as org1, org2 e org3)\n\n\n\n\nChaincode Details\n\n\nO chaincode disponibilizado possui as seguintes carater\u00edsticas:\n\n\n\n\n3 assets\n\n\n1 private data\n\n\n3 transa\u00e7\u00f5es\n\n\n\n\nMSP Configuration\n\n\nAs redes Hyperledger Fabric necessitam de correta configura\u00e7\u00e3o dos certificados digitais x.509 agrupados em elementos demoninado \nMembership Service Provider\n ou simplesmente chamados \nMSP\n\n\nOs certificados s\u00e3o gerados e adminstrados por autoridades certificadora (\nCA\n) utilizando a plataforma \nHyperledger Fabric CA\n. Cada organiza\u00e7\u00e3o (org1, org2 e org3) ser\u00e1 representada por uma \nCA\n\n\n\n\nNOTE\n\n\nN\u00e3o \u00e9 objetivo desse tutorial ensinar os conceitos de MSP ou do \nHyperledger Fabric CA\n\n\n\n\nA gera\u00e7\u00e3o dos certificados e MSP necess\u00e1rios para gera\u00e7\u00e3o da rede \u00e9 realizado atrav\u00e9s do script abaixo a ser executado na pasta fabric:\n\n\ncd fabric \\\nrm -rf crypto-config channel-artifacts ca && \\\n./startDev.sh generate && \\\ncd ..\n\n\n\n\nEsse script ira subir 3 containers do \nHyperledger Fabric CA\n\n- ca.org1.example.com\n- ca.org2.example.com\n- ca.org3.example.com\n\n\nAo final 3 pastas ser\u00e3o criadas com os artefatos criptogr\u00e1ficos necess\u00e1rios para a gera\u00e7\u00e3o da rede\n\n\n.\n\u251c\u2500\u2500 fabric\n    \u2514\u2500\u2500 ca    \n    \u2514\u2500\u2500 crypto-config\n    \u2514\u2500\u2500 channel-artifacts\n\n\n\n\nVendoring\n\n\nTanto o chaincode em GoLang quanto a rest-server em NodeJs precisam ser vendorados (baixar os pacotes de depend\u00eancias) para poderem funcionar.\n\n\nPara baixar as depend\u00eancias do chaincode deve ser executado o seguinte script:\n\n\ncd chaincode && \\\ngo mod vendor && \\\ncd ..\n\n\n\n\nPara baixar as depend\u00eancias do rest-server deve ser executado o seguinte script\n\n\ncd rest-server && \\\nnpm install && \\\ncd ..\n\n\n\n\nBuilding your GoLedger CC-Tools network\n\n\nDepois da instalac\u00e3o do ambiente, gera\u00e7\u00e3o dos certificados e vendora\u00e7\u00e3o dos pacotes, a rede est\u00e1 pronta para ser instanciada.\n\n\nEsse processo se d\u00e1 com o seguinte script\n\n\n./startDev.sh\n\n\n\n\nEsse script ir\u00e1 executar as seguintes tarefas:\n\n\n\n\nCriar os containers para o n\u00f3s do Blockchain (peers e ordereres no \nHyperledger Fabric\n) para as 3 orgs (org1, org2, org3) com a correta configura\u00e7\u00e3o criptogr\u00e1fica para cada um deles.\n\n\nCriar o ledger para registro e permissionamento - \nHyperledger Fabric Channel\n\n\nEntrada das organiza\u00e7\u00f5es no channel (processo de Join no \nHyperledger Fabric\n)\n\n\nInstala\u00e7\u00e3o do chaincode nos endorsing peers\n\n\nInstala\u00e7\u00e3o da api de gerenciamento da rede \nHyperledger Fabric\n\n\nInstanciar o chaincode no channel\n\n\nCriar os containers para as Rest servers com a correta configura\u00e7\u00e3o criptogr\u00e1fica para respresentarem um \nHyperledger Fabric Client\n para cada organiza\u00e7\u00e3o.\n\n\n\n\nAo final do processo, deve ser apresentado as seguintes mensagens\n\n\nCreate channel - mainchannel\n{\"status\":\"SUCCESS\",\"created\":true}\n\nJoin org1 to channel\n{\"status\":\"SUCCESS\"}\n\nJoin org2 to channel\n{\"status\":\"SUCCESS\"}\n\nJoin org3 to channel\n{\"status\":\"SUCCESS\"}\n\nUpdate anchor peers on org1\n{\"status\":\"SUCCESS\"}\n\nUpdate anchor peers on org2\n{\"status\":\"SUCCESS\"}\n\nUpdate anchor peers on org3\n{\"status\":\"SUCCESS\"}\n\nInstall network chaincode on org1\n{\"installed\":true,\"version\":\"1.0\"}\n\nInstall network chaincode on org2\n{\"installed\":true,\"version\":\"1.0\"}\n\nInstall network chaincode on org3\n{\"installed\":true,\"version\":\"1.0\"}\n\nInstantiate network chaincode\n{\"started\":true}\n\nInstall chaincode on org1\n\nInstall chaincode on org2\n\nInstall chaincode on org3\n\nInstantiate chaincode\n{\"started\":true}\n\nNetwork cc-tools-demo-net is external, skipping\nCreating ccapi.org1.example.com ... done\nCreating ccapi.org2.example.com ... done\nCreating ccapi.org3.example.com ... done\n\n\n\n\nOs containers \nccapi\n representam os servidores rest para cada organiza\u00e7\u00e3o. Eles podem levar alguns minutos para ficarem online.\n\n\nAo final, a seguinte mensagem deve aparecer:\n\n\ndocker logs ccapi.org1.example.com \n\n> cc-tools-demoapi@1.0.0 start /rest-server\n> gulp default; gulp start\n\n[23:12:58] Using gulpfile /rest-server/gulpfile.js\n[23:12:58] Starting 'default'...\n[23:12:58] Starting 'assets'...\n[23:12:59] Finished 'default' after 49 ms\n[23:12:59] Finished 'assets' after 51 ms\n[23:13:40] Using gulpfile /rest-server/gulpfile.js\n[23:13:40] Starting 'start'...\n[23:13:41] [nodemon] 1.19.0\n[23:13:41] [nodemon] to restart at any time, enter `rs`\n[23:13:41] [nodemon] watching: /rest-server/src/**/*\n[23:13:41] [nodemon] starting `node dist/`\nListening on port 80\n\n\n\n\n\n\nNOTE\n\n\nEm alguns equipamentos pode aparecer a seguinte mensagem de erro:\n\n\nError: Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: node-v57-linux-x64-glibc\nFound: [node-v64-linux-x64-glibc]\n\n\nNesse caso deve-se rodar o seguinte script\n\n\ncd rest-server\nnpm rebuild --target=8.1.0 --target_platform=linux --target_arch=x64 --target_libc=glibc --update-binary\ncd ..\n\n\n\n\n\n\nUpdating your chaincode\n\n\nA atualiza\u00e7\u00e3o de um contrato inteligente pode ser feita de forma facilitada nos chaincodes que utilizam a biblioteca \nGoLedger CC-Tools\n.\n\n\nPrimeramente, deve-se verificar a sintaxe do c\u00f3digo modificado.\n\n\ncd chaincode \\\ngo vet \\\ncd ..\n\n\n\n\nAp\u00f3s a valida\u00e7\u00e3o, a atualiza\u00e7\u00e3o do chaincode \u00e9 feito com o script \nupgradeCC.sh\n, que recebe como argumento a vers\u00e3o do chaincode. \n\n\n\n\nNOTE\n\n\nUm chaincode sempre deve ser atualizado com uma vers\u00e3o diferente de todas as vers\u00f5es anteriores.\n\n\n\n\nExemplo:\n\n\n./upgradeCC.sh 0.2",
            "title": "Tutorial"
        },
        {
            "location": "/Tutorial/#writing-your-first-application",
            "text": "Neste tutorial, iremos instalar e utilizar um contrato inteligente (chaincode).  \u00c9 necess\u00e1rio estar com o ambiente configurado para poder realizar esse tutorial. Detalhes em  Getting Started  Veremos como a biblioteca GoLedger CC-Tools funciona, utilizando os artefatos disponibilizados pela GoLedger   Rest-server integrada  Api de atualiza\u00e7\u00e3o Hyperledger Fabric  Aplica\u00e7\u00e3o Web de desenvolvimento (cc-web)   O contrato inteligente do resposit\u00f3rio cc-tool-demo \u00e9 ideal para os iniciantes ao desenvolvimento na tecnologia Hyperledger Fabric. \u00c9 um \u00f3timo ponto de partida para entender uma blockchain do Hyperledger Fabric e facilitar a jornada para o deenvolvimento de aplica\u00e7\u00f5es utilizando esse framework.   Voc\u00ea aprender\u00e1 como escrever um aplicativo e um contrato inteligente (chaincode) para consultar e atualizar um livro raz\u00e3o, e como se conectar com o Blockchain atrav\u00e9s de uma API pronta para uso.   NOTE  \u00c9 necess\u00e1rio conhecer a linguagem de programa\u00e7\u00e3o  GoLang  para realizar esse tutorial.",
            "title": "Writing Your First Application"
        },
        {
            "location": "/Tutorial/#network-details",
            "text": "A rede a ser criada ter\u00e1 a seguinte configura\u00e7\u00e3o:   1 chaincode (cc-tools-demo)  3 orgs (org1, org2, org3)  3 clients (rest-server para as org1, org2 e org3)",
            "title": "Network Details"
        },
        {
            "location": "/Tutorial/#chaincode-details",
            "text": "O chaincode disponibilizado possui as seguintes carater\u00edsticas:   3 assets  1 private data  3 transa\u00e7\u00f5es",
            "title": "Chaincode Details"
        },
        {
            "location": "/Tutorial/#msp-configuration",
            "text": "As redes Hyperledger Fabric necessitam de correta configura\u00e7\u00e3o dos certificados digitais x.509 agrupados em elementos demoninado  Membership Service Provider  ou simplesmente chamados  MSP  Os certificados s\u00e3o gerados e adminstrados por autoridades certificadora ( CA ) utilizando a plataforma  Hyperledger Fabric CA . Cada organiza\u00e7\u00e3o (org1, org2 e org3) ser\u00e1 representada por uma  CA   NOTE  N\u00e3o \u00e9 objetivo desse tutorial ensinar os conceitos de MSP ou do  Hyperledger Fabric CA   A gera\u00e7\u00e3o dos certificados e MSP necess\u00e1rios para gera\u00e7\u00e3o da rede \u00e9 realizado atrav\u00e9s do script abaixo a ser executado na pasta fabric:  cd fabric \\\nrm -rf crypto-config channel-artifacts ca && \\\n./startDev.sh generate && \\\ncd ..  Esse script ira subir 3 containers do  Hyperledger Fabric CA \n- ca.org1.example.com\n- ca.org2.example.com\n- ca.org3.example.com  Ao final 3 pastas ser\u00e3o criadas com os artefatos criptogr\u00e1ficos necess\u00e1rios para a gera\u00e7\u00e3o da rede  .\n\u251c\u2500\u2500 fabric\n    \u2514\u2500\u2500 ca    \n    \u2514\u2500\u2500 crypto-config\n    \u2514\u2500\u2500 channel-artifacts",
            "title": "MSP Configuration"
        },
        {
            "location": "/Tutorial/#vendoring",
            "text": "Tanto o chaincode em GoLang quanto a rest-server em NodeJs precisam ser vendorados (baixar os pacotes de depend\u00eancias) para poderem funcionar.  Para baixar as depend\u00eancias do chaincode deve ser executado o seguinte script:  cd chaincode && \\\ngo mod vendor && \\\ncd ..  Para baixar as depend\u00eancias do rest-server deve ser executado o seguinte script  cd rest-server && \\\nnpm install && \\\ncd ..",
            "title": "Vendoring"
        },
        {
            "location": "/Tutorial/#building-your-goledger-cc-tools-network",
            "text": "Depois da instalac\u00e3o do ambiente, gera\u00e7\u00e3o dos certificados e vendora\u00e7\u00e3o dos pacotes, a rede est\u00e1 pronta para ser instanciada.  Esse processo se d\u00e1 com o seguinte script  ./startDev.sh  Esse script ir\u00e1 executar as seguintes tarefas:   Criar os containers para o n\u00f3s do Blockchain (peers e ordereres no  Hyperledger Fabric ) para as 3 orgs (org1, org2, org3) com a correta configura\u00e7\u00e3o criptogr\u00e1fica para cada um deles.  Criar o ledger para registro e permissionamento -  Hyperledger Fabric Channel  Entrada das organiza\u00e7\u00f5es no channel (processo de Join no  Hyperledger Fabric )  Instala\u00e7\u00e3o do chaincode nos endorsing peers  Instala\u00e7\u00e3o da api de gerenciamento da rede  Hyperledger Fabric  Instanciar o chaincode no channel  Criar os containers para as Rest servers com a correta configura\u00e7\u00e3o criptogr\u00e1fica para respresentarem um  Hyperledger Fabric Client  para cada organiza\u00e7\u00e3o.   Ao final do processo, deve ser apresentado as seguintes mensagens  Create channel - mainchannel\n{\"status\":\"SUCCESS\",\"created\":true}\n\nJoin org1 to channel\n{\"status\":\"SUCCESS\"}\n\nJoin org2 to channel\n{\"status\":\"SUCCESS\"}\n\nJoin org3 to channel\n{\"status\":\"SUCCESS\"}\n\nUpdate anchor peers on org1\n{\"status\":\"SUCCESS\"}\n\nUpdate anchor peers on org2\n{\"status\":\"SUCCESS\"}\n\nUpdate anchor peers on org3\n{\"status\":\"SUCCESS\"}\n\nInstall network chaincode on org1\n{\"installed\":true,\"version\":\"1.0\"}\n\nInstall network chaincode on org2\n{\"installed\":true,\"version\":\"1.0\"}\n\nInstall network chaincode on org3\n{\"installed\":true,\"version\":\"1.0\"}\n\nInstantiate network chaincode\n{\"started\":true}\n\nInstall chaincode on org1\n\nInstall chaincode on org2\n\nInstall chaincode on org3\n\nInstantiate chaincode\n{\"started\":true}\n\nNetwork cc-tools-demo-net is external, skipping\nCreating ccapi.org1.example.com ... done\nCreating ccapi.org2.example.com ... done\nCreating ccapi.org3.example.com ... done  Os containers  ccapi  representam os servidores rest para cada organiza\u00e7\u00e3o. Eles podem levar alguns minutos para ficarem online.  Ao final, a seguinte mensagem deve aparecer:  docker logs ccapi.org1.example.com \n\n> cc-tools-demoapi@1.0.0 start /rest-server\n> gulp default; gulp start\n\n[23:12:58] Using gulpfile /rest-server/gulpfile.js\n[23:12:58] Starting 'default'...\n[23:12:58] Starting 'assets'...\n[23:12:59] Finished 'default' after 49 ms\n[23:12:59] Finished 'assets' after 51 ms\n[23:13:40] Using gulpfile /rest-server/gulpfile.js\n[23:13:40] Starting 'start'...\n[23:13:41] [nodemon] 1.19.0\n[23:13:41] [nodemon] to restart at any time, enter `rs`\n[23:13:41] [nodemon] watching: /rest-server/src/**/*\n[23:13:41] [nodemon] starting `node dist/`\nListening on port 80   NOTE  Em alguns equipamentos pode aparecer a seguinte mensagem de erro:  Error: Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: node-v57-linux-x64-glibc\nFound: [node-v64-linux-x64-glibc]  Nesse caso deve-se rodar o seguinte script  cd rest-server\nnpm rebuild --target=8.1.0 --target_platform=linux --target_arch=x64 --target_libc=glibc --update-binary\ncd ..",
            "title": "Building your GoLedger CC-Tools network"
        },
        {
            "location": "/Tutorial/#updating-your-chaincode",
            "text": "A atualiza\u00e7\u00e3o de um contrato inteligente pode ser feita de forma facilitada nos chaincodes que utilizam a biblioteca  GoLedger CC-Tools .  Primeramente, deve-se verificar a sintaxe do c\u00f3digo modificado.  cd chaincode \\\ngo vet \\\ncd ..  Ap\u00f3s a valida\u00e7\u00e3o, a atualiza\u00e7\u00e3o do chaincode \u00e9 feito com o script  upgradeCC.sh , que recebe como argumento a vers\u00e3o do chaincode.    NOTE  Um chaincode sempre deve ser atualizado com uma vers\u00e3o diferente de todas as vers\u00f5es anteriores.   Exemplo:  ./upgradeCC.sh 0.2",
            "title": "Updating your chaincode"
        },
        {
            "location": "/about/",
            "text": "Introdu\u00e7\u00e3o\n\n\nUrbes raucos\n\n\nLorem markdownum mutatur mixtos Coroniden, his Idaeo abundet sequentes interdum\nIcare, iam aequum. Posti miserae. Vastum animo; obfuit, mea super petiit axes\namabam \npossent nocituraque\n iacent Antiphates illa fretum duobus proxima.\nDixit recentibus amor inmensum intabescere \nmissi\n, de secundum quicquam.\n\n\nHerculis oranti, urbis sed multi populos, maternis dei! Vates restat. Verso\nnatos mutata fronde et viri \ncaeli\n et referam! In morte, redeamus dum \nquodque\ntorvos\n, servare brevissimus sit cum quae turba, sua. \nNoctes faces arida\n unda\nsimul, et vites nata.\n\n\n\n\nAere sint\n\n\nDemptos timide simulatoremque Aesaris frustra conticuit subterque\n\n\nIovi domitamque pictas dea Dulichium fetibus simul\n\n\nPositas ire\n\n\n\n\nExpellitur mens taurus Procri\n\n\nSortis deus amnis luctor hortaturque accipe opus, pete bene. Cum tecta, et super\nmunera? Quo ut fida dat quas magna mota erat de ac abest da e humum solvi\nTantalus.\n\n\nsata_traceroute_disk.dashboardMemoryBps += importGifSyntax;\nif (1 + access) {\n    command_logic(1, master_drive_png);\n    memory_paste = wordError.sms.e(alu + webmail, 1 + 1);\n    media.web(kerning_firewire_file - pdfIcannBezel, mips,\n            led.system_snmp.isaVolumePpga(53));\n}\nif (cmos(copyWampCrop, user) * filePrinterDdr) {\n    iphoneTiffWamp = onPipelinePci(waisHardening);\n    table_character(balancingUml, 82 * hyper_virtual);\n    cyberbullying(torrent_search);\n} else {\n    typeface_data_manet = 4 - up + pptpAutoresponder;\n    lpiSsid -= seo_network;\n    media_virus(softwareDebug - browser_subnet_ntfs);\n}\nhard_bios_compression += metadata_os_p + repository_troll_flash(\n        meme_token_recursive, 1, 4) + market_horizontal(dvdOnly, ring *\n        irc_data_read);\nvar clientHypertext = whois(vpn_networking_unix, keywordsFat(\n        ipvTimeBacklink));\n\n\n\nTyranni velari. Fila \nmori nobis crines\n Ne arripit Troiae muneris et prior,\nMenoetae vespere, et et. Cuique temperat forti; sanguine negat non, vimine\nvitat, nescio. Bidentum micant.\n\n\nPrimus in retenta coniectos circuitu. Non Pentheus est superest Aeacide natus\n\nniveis soluti solus\n fatale et. Cur arvis Quid unde velatus vocant, sed est\nPagasaea fixa crudele inquit quam.\n\n\nFlammis dedit, comes sibi dis, nec vicem valeant trabes meruere. Feritatis\niuvenis solita nulla, de quod regis gramine nobilitas effudit. Me aequora\n\nfurcas\n et aberant Cephisias scopulos dare vicinia in nentes auctor quibus\namat, suum habet. Me aere, tantum ex in haec, cogamque, facta illa, qui.",
            "title": "About"
        },
        {
            "location": "/about/#introducao",
            "text": "",
            "title": "Introdu\u00e7\u00e3o"
        },
        {
            "location": "/about/#urbes-raucos",
            "text": "Lorem markdownum mutatur mixtos Coroniden, his Idaeo abundet sequentes interdum\nIcare, iam aequum. Posti miserae. Vastum animo; obfuit, mea super petiit axes\namabam  possent nocituraque  iacent Antiphates illa fretum duobus proxima.\nDixit recentibus amor inmensum intabescere  missi , de secundum quicquam.  Herculis oranti, urbis sed multi populos, maternis dei! Vates restat. Verso\nnatos mutata fronde et viri  caeli  et referam! In morte, redeamus dum  quodque\ntorvos , servare brevissimus sit cum quae turba, sua.  Noctes faces arida  unda\nsimul, et vites nata.   Aere sint  Demptos timide simulatoremque Aesaris frustra conticuit subterque  Iovi domitamque pictas dea Dulichium fetibus simul  Positas ire",
            "title": "Urbes raucos"
        },
        {
            "location": "/about/#expellitur-mens-taurus-procri",
            "text": "Sortis deus amnis luctor hortaturque accipe opus, pete bene. Cum tecta, et super\nmunera? Quo ut fida dat quas magna mota erat de ac abest da e humum solvi\nTantalus.  sata_traceroute_disk.dashboardMemoryBps += importGifSyntax;\nif (1 + access) {\n    command_logic(1, master_drive_png);\n    memory_paste = wordError.sms.e(alu + webmail, 1 + 1);\n    media.web(kerning_firewire_file - pdfIcannBezel, mips,\n            led.system_snmp.isaVolumePpga(53));\n}\nif (cmos(copyWampCrop, user) * filePrinterDdr) {\n    iphoneTiffWamp = onPipelinePci(waisHardening);\n    table_character(balancingUml, 82 * hyper_virtual);\n    cyberbullying(torrent_search);\n} else {\n    typeface_data_manet = 4 - up + pptpAutoresponder;\n    lpiSsid -= seo_network;\n    media_virus(softwareDebug - browser_subnet_ntfs);\n}\nhard_bios_compression += metadata_os_p + repository_troll_flash(\n        meme_token_recursive, 1, 4) + market_horizontal(dvdOnly, ring *\n        irc_data_read);\nvar clientHypertext = whois(vpn_networking_unix, keywordsFat(\n        ipvTimeBacklink));  Tyranni velari. Fila  mori nobis crines  Ne arripit Troiae muneris et prior,\nMenoetae vespere, et et. Cuique temperat forti; sanguine negat non, vimine\nvitat, nescio. Bidentum micant.  Primus in retenta coniectos circuitu. Non Pentheus est superest Aeacide natus niveis soluti solus  fatale et. Cur arvis Quid unde velatus vocant, sed est\nPagasaea fixa crudele inquit quam.  Flammis dedit, comes sibi dis, nec vicem valeant trabes meruere. Feritatis\niuvenis solita nulla, de quod regis gramine nobilitas effudit. Me aequora furcas  et aberant Cephisias scopulos dare vicinia in nentes auctor quibus\namat, suum habet. Me aere, tantum ex in haec, cogamque, facta illa, qui.",
            "title": "Expellitur mens taurus Procri"
        }
    ]
}