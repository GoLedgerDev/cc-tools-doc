{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CC-Tools documentation \ud83d\udc4b The GoLedger CC-Tools library is a collaborative effort from GoLedger to provide developers a powerful and easy-to-use library for creating Hyperledger Fabric chaincodes. Developed using GoLang, the GoLedger CC-Tools library has several features that facilitate the journey of learning, development and deployment in production of a chaincode. GoLedger CC-Tools is an open-source project lead by GoLedger and open for use to the Hyperledger development community. Here's where you can start: Getting Started Tutorials Key concepts Assets Transactions Reference guides Features Standard asset data mapping (and their properties) Encapsulation of Hyperledger Fabric chaincode sdk interface functions Standard asset key management Basic types of asset properties (text, number, boolean, date) available Basic asset array type (text, number or date arrays) available New asset property types customization Asset within assets available as references Asset array available as references Management of asset details Write permissions by set of organizations for each asset's property Private data collections management by asset (read permissions) Create/Read/Update/Delete (CRUD) transactions embedded Custom transactions, with prior definition of arguments, webservice method (GET, POST etc) Management of transaction details Compatible web service Compatible ready-to-use web application","title":"Home"},{"location":"#welcome-to-cc-tools-documentation","text":"The GoLedger CC-Tools library is a collaborative effort from GoLedger to provide developers a powerful and easy-to-use library for creating Hyperledger Fabric chaincodes. Developed using GoLang, the GoLedger CC-Tools library has several features that facilitate the journey of learning, development and deployment in production of a chaincode. GoLedger CC-Tools is an open-source project lead by GoLedger and open for use to the Hyperledger development community. Here's where you can start: Getting Started Tutorials Key concepts Assets Transactions Reference guides","title":"Welcome to CC-Tools documentation \ud83d\udc4b"},{"location":"#features","text":"Standard asset data mapping (and their properties) Encapsulation of Hyperledger Fabric chaincode sdk interface functions Standard asset key management Basic types of asset properties (text, number, boolean, date) available Basic asset array type (text, number or date arrays) available New asset property types customization Asset within assets available as references Asset array available as references Management of asset details Write permissions by set of organizations for each asset's property Private data collections management by asset (read permissions) Create/Read/Update/Delete (CRUD) transactions embedded Custom transactions, with prior definition of arguments, webservice method (GET, POST etc) Management of transaction details Compatible web service Compatible ready-to-use web application","title":"Features"},{"location":"about/","text":"Introdu\u00e7\u00e3o Urbes raucos Lorem markdownum mutatur mixtos Coroniden, his Idaeo abundet sequentes interdum Icare, iam aequum. Posti miserae. Vastum animo; obfuit, mea super petiit axes amabam possent nocituraque iacent Antiphates illa fretum duobus proxima. Dixit recentibus amor inmensum intabescere missi , de secundum quicquam. Herculis oranti, urbis sed multi populos, maternis dei! Vates restat. Verso natos mutata fronde et viri caeli et referam! In morte, redeamus dum quodque torvos , servare brevissimus sit cum quae turba, sua. Noctes faces arida unda simul, et vites nata. Aere sint Demptos timide simulatoremque Aesaris frustra conticuit subterque Iovi domitamque pictas dea Dulichium fetibus simul Positas ire Expellitur mens taurus Procri Sortis deus amnis luctor hortaturque accipe opus, pete bene. Cum tecta, et super munera? Quo ut fida dat quas magna mota erat de ac abest da e humum solvi Tantalus. sata_traceroute_disk.dashboardMemoryBps += importGifSyntax; if (1 + access) { command_logic(1, master_drive_png); memory_paste = wordError.sms.e(alu + webmail, 1 + 1); media.web(kerning_firewire_file - pdfIcannBezel, mips, led.system_snmp.isaVolumePpga(53)); } if (cmos(copyWampCrop, user) * filePrinterDdr) { iphoneTiffWamp = onPipelinePci(waisHardening); table_character(balancingUml, 82 * hyper_virtual); cyberbullying(torrent_search); } else { typeface_data_manet = 4 - up + pptpAutoresponder; lpiSsid -= seo_network; media_virus(softwareDebug - browser_subnet_ntfs); } hard_bios_compression += metadata_os_p + repository_troll_flash( meme_token_recursive, 1, 4) + market_horizontal(dvdOnly, ring * irc_data_read); var clientHypertext = whois(vpn_networking_unix, keywordsFat( ipvTimeBacklink)); Tyranni velari. Fila mori nobis crines Ne arripit Troiae muneris et prior, Menoetae vespere, et et. Cuique temperat forti; sanguine negat non, vimine vitat, nescio. Bidentum micant. Primus in retenta coniectos circuitu. Non Pentheus est superest Aeacide natus niveis soluti solus fatale et. Cur arvis Quid unde velatus vocant, sed est Pagasaea fixa crudele inquit quam. Flammis dedit, comes sibi dis, nec vicem valeant trabes meruere. Feritatis iuvenis solita nulla, de quod regis gramine nobilitas effudit. Me aequora furcas et aberant Cephisias scopulos dare vicinia in nentes auctor quibus amat, suum habet. Me aere, tantum ex in haec, cogamque, facta illa, qui.","title":"Introdu\u00e7\u00e3o"},{"location":"about/#introducao","text":"","title":"Introdu\u00e7\u00e3o"},{"location":"about/#urbes-raucos","text":"Lorem markdownum mutatur mixtos Coroniden, his Idaeo abundet sequentes interdum Icare, iam aequum. Posti miserae. Vastum animo; obfuit, mea super petiit axes amabam possent nocituraque iacent Antiphates illa fretum duobus proxima. Dixit recentibus amor inmensum intabescere missi , de secundum quicquam. Herculis oranti, urbis sed multi populos, maternis dei! Vates restat. Verso natos mutata fronde et viri caeli et referam! In morte, redeamus dum quodque torvos , servare brevissimus sit cum quae turba, sua. Noctes faces arida unda simul, et vites nata. Aere sint Demptos timide simulatoremque Aesaris frustra conticuit subterque Iovi domitamque pictas dea Dulichium fetibus simul Positas ire","title":"Urbes raucos"},{"location":"about/#expellitur-mens-taurus-procri","text":"Sortis deus amnis luctor hortaturque accipe opus, pete bene. Cum tecta, et super munera? Quo ut fida dat quas magna mota erat de ac abest da e humum solvi Tantalus. sata_traceroute_disk.dashboardMemoryBps += importGifSyntax; if (1 + access) { command_logic(1, master_drive_png); memory_paste = wordError.sms.e(alu + webmail, 1 + 1); media.web(kerning_firewire_file - pdfIcannBezel, mips, led.system_snmp.isaVolumePpga(53)); } if (cmos(copyWampCrop, user) * filePrinterDdr) { iphoneTiffWamp = onPipelinePci(waisHardening); table_character(balancingUml, 82 * hyper_virtual); cyberbullying(torrent_search); } else { typeface_data_manet = 4 - up + pptpAutoresponder; lpiSsid -= seo_network; media_virus(softwareDebug - browser_subnet_ntfs); } hard_bios_compression += metadata_os_p + repository_troll_flash( meme_token_recursive, 1, 4) + market_horizontal(dvdOnly, ring * irc_data_read); var clientHypertext = whois(vpn_networking_unix, keywordsFat( ipvTimeBacklink)); Tyranni velari. Fila mori nobis crines Ne arripit Troiae muneris et prior, Menoetae vespere, et et. Cuique temperat forti; sanguine negat non, vimine vitat, nescio. Bidentum micant. Primus in retenta coniectos circuitu. Non Pentheus est superest Aeacide natus niveis soluti solus fatale et. Cur arvis Quid unde velatus vocant, sed est Pagasaea fixa crudele inquit quam. Flammis dedit, comes sibi dis, nec vicem valeant trabes meruere. Feritatis iuvenis solita nulla, de quod regis gramine nobilitas effudit. Me aequora furcas et aberant Cephisias scopulos dare vicinia in nentes auctor quibus amat, suum habet. Me aere, tantum ex in haec, cogamque, facta illa, qui.","title":"Expellitur mens taurus Procri"},{"location":"assets/","text":"Assets Blockchain assets represent the information that will be used by the Blockchain ledger ( Hyperledger Fabric Channel ) Roughly speaking, an asset can be compared to a table in a relational database. And just like in databases, assets are formed by properties, some of which can be part of a set of keys for that asset. Each property can have a specific data type, such as string, number, boolean, etc. An asset can also be a Hyperledger Fabric Private Data , in which the information content is recorded in a transient database outside the ledger and only a subset of organizations receive this data, configuring readability. For the cc-tools-demo repository, there are 4 assets (one of which is a private data) Person Book Library Secret (private data) In order to use GoLedger CC-Tools library, the assets definition is done in the chaincode/assettypes folder Here follow the list of files: chaincode/ assettypes/ # asset folders person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) assetTypeList.go # list of assets instantiated Asset definition The construction and definition of an asset is done by creating a file at chaincode/assettypes folder An asset has the following fields Tag : string field used to define the name of the asset referenced internally by the code and by the Rest Api endpoints. No space or special characters allowed. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Props : asset properties. It has its own fields (description next) Readers : used to define private data organizations (needs additional configuration in collections.json file) Property definition An asset has a set of properties (Props) to structure the asset. A property has the following fields: IsKey : identifies if the property is part of the asset's keys. Boolean field. Required : identifies if the property is mandatory. Boolean field. ReadOnly : identifies if the property can no longer be modified once created. Boolean field. DefaultValue : property default value. Writers : define the organizations that can create or change this property. If the property is key (isKey field: true) then the entire asset can only be created by the organization. List of strings. DataType : property type. CC-Tools has the following default types: string, number, datetime and boolean . Custom types can be defined in the chaincode/datatypes folder. Validity : property validity function. It is suggested only for simple validations, more complex functions should use custom datatypes. Asset examples The cc-tools-demo repository has the following examples: chaincode/ assettypes/ # asset foldgers person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) assetTypeList.go # list of assets instantiated Besides the files of each asset, you must register the assets that can be used by the Goledger CC-Tools library in the assetTypeList.go file The definition of the Person asset is as follows: var Person = assets.AssetType{ Tag: \"person\", Label: \"Person\", Description: \"Personal data of someone\", Props: []assets.AssetProp{ { // Primary key Required: true, IsKey: true, Tag: \"id\", Label: \"CPF (Brazilian ID)\", DataType: \"cpf\", // Datatypes are identified at datatypes folder Writers: []string{`org1MSP`}, // This means only org1 can create the asset (others can edit) }, { // Mandatory property Required: true, Tag: \"name\", Label: \"Asset Name\", DataType: \"string\", // Validate funcion Validate: func(name interface{}) error { nameStr := name.(string) if nameStr == \"\" { return fmt.Errorf(\"name must be non-empty\") } return nil }, }, { // Optional property Tag: \"dateOfBirth\", Label: \"Date of Birth\", DataType: \"datetime\", }, { // Property with default value Tag: \"height\", Label: \"Person's height\", DefaultValue: 0, DataType: \"number\", }, }, } According to the description above, the asset Person has the following characteristics: Primary key cpf (custom datatype) Only org1 can create or change the cpf property and the Person asset (because this is a key) Property name of type string is mandatory, and has automatic validation to prevent empty strings (\"\") dateofBirth property of type datetime optional. height property of type number , with default value 0 The definition of the Book asset is as follows: var Book = assets.AssetType{ Tag: \"book\", Label: \"Book\", Description: \"\", Props: []assets.AssetProp{ { // Composite Key Required: true, IsKey: true, Tag: \"title\", Label: \"Book Title\", DataType: \"string\", Writers: []string{`org2MSP`}, // This means only org2 can create the asset (others can edit) }, { // Composite Key Required: true, IsKey: true, Tag: \"author\", Label: \"Book Author\", DataType: \"string\", Writers: []string{`org2MSP`}, // This means only org2 can create the asset (others can edit) }, { /// Reference to another asset Tag: \"currentTenant\", Label: \"Current Tenant\", DataType: \"->person\", }, { // String list Tag: \"genres\", Label: \"Genres\", DataType: \"[]string\", }, { // Date property Tag: \"published\", Label: \"Publishment Date\", DataType: \"datetime\", }, }, } According to the description above, the Book asset has the following characteristics: Composite key title and author , both with type string Only org2 can create or change the title and author properties and the Book asset (because they are keys) currentTenant property of type ->person which represents the reference to a Person asset genres property of type []string which represents an array of strings published property of type datetime The definition of the Library asset is as follows: var Library = assets.AssetType{ Tag: \"library\", Label: \"Library\", Description: \"Library as a collection of books\", Props: []assets.AssetProp{ { // Primary Key Required: true, IsKey: true, Tag: \"name\", Label: \"Library Name\", DataType: \"string\", Writers: []string{`org3MSP`}, // This means only org3 can create the asset (others can edit) }, { // Asset reference list Tag: \"books\", Label: \"Book Collection\", DataType: \"[]->book\", }, { // Asset reference list Tag: \"entranceCode\", Label: \"Entrance Code for the Library\", DataType: \"->secret\", }, }, } According to the description above, the Library asset has the following characteristics: Primary key name of type string Only org3 can create or change the name property and the Library asset (because it's key) books property of type []->book which represents an array of references to the Book asset entranceCode property of type ->secret which represents the reference to a private data type The definition of the Secret asset is as follows: var Secret = assets.AssetType{ Tag: \"secret\", Label: \"Secret\", Description: \"Secret between Org2 and Org3\", Readers: []string{\"org2MSP\", \"org3MSP\"}, Props: []assets.AssetProp{ { // Primary Key IsKey: true, Tag: \"secretName\", Label: \"Secret Name\", DataType: \"string\", Writers: []string{`org2MSP`}, // This means only org2 can create the asset (org3 can edit) }, { // Mandatory Property Required: true, Tag: \"secret\", Label: \"Secret\", DataType: \"string\", }, }, } According to the description above, Secret asset has privacy features ( Hyperledger Fabric Private Data ). For this asset to work correctly, the collections.json file must be configured We will not describe Hyperledger Fabric Private Data concepts, its operation, policy rules, etc. But to put it simply, when an asset is defined as private, only its content hash is recorded in channel , the asset's content (its properties) are only accessed by a limited set of organizations, the content recorded in transient databases in each peer. Asset content can only be read by org2 and org3 Primary key secretName of type string Only org2 can create or change the secretName property and the Secret asset (because it is key) secret property of type string is mandatory for the asset Both org2 and org3 can create or change the secret property The collections.json file needs to be configured according to the assets that have the Readers field [ { \"name\": \"secret\", \"policy\": { \"identities\": [ { \"role\": { \"name\": \"member\", \"mspId\": \"org2MSP\" } }, { \"role\": { \"name\": \"member\", \"mspId\": \"org3MSP\" } } ], \"policy\": { \"1-of\": [ { \"signed-by\": 0 }, { \"signed-by\": 1 } ] } }, \"requiredPeerCount\": 0, \"maxPeerCount\": 3, \"blockToLive\": 1000000, \"memberOnlyRead\": true } ] Asset list definition GoLedger CC-Tools assets registration must be defined in the chaincode/assetTypeList.go file** var assetTypeList = []assets.AssetType{ assettypes.Person, assettypes.Book, assettypes.Library, assettypes.Secret, }","title":"Assets"},{"location":"assets/#assets","text":"Blockchain assets represent the information that will be used by the Blockchain ledger ( Hyperledger Fabric Channel ) Roughly speaking, an asset can be compared to a table in a relational database. And just like in databases, assets are formed by properties, some of which can be part of a set of keys for that asset. Each property can have a specific data type, such as string, number, boolean, etc. An asset can also be a Hyperledger Fabric Private Data , in which the information content is recorded in a transient database outside the ledger and only a subset of organizations receive this data, configuring readability. For the cc-tools-demo repository, there are 4 assets (one of which is a private data) Person Book Library Secret (private data) In order to use GoLedger CC-Tools library, the assets definition is done in the chaincode/assettypes folder Here follow the list of files: chaincode/ assettypes/ # asset folders person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) assetTypeList.go # list of assets instantiated","title":"Assets"},{"location":"assets/#asset-definition","text":"The construction and definition of an asset is done by creating a file at chaincode/assettypes folder An asset has the following fields Tag : string field used to define the name of the asset referenced internally by the code and by the Rest Api endpoints. No space or special characters allowed. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Props : asset properties. It has its own fields (description next) Readers : used to define private data organizations (needs additional configuration in collections.json file)","title":"Asset definition"},{"location":"assets/#property-definition","text":"An asset has a set of properties (Props) to structure the asset. A property has the following fields: IsKey : identifies if the property is part of the asset's keys. Boolean field. Required : identifies if the property is mandatory. Boolean field. ReadOnly : identifies if the property can no longer be modified once created. Boolean field. DefaultValue : property default value. Writers : define the organizations that can create or change this property. If the property is key (isKey field: true) then the entire asset can only be created by the organization. List of strings. DataType : property type. CC-Tools has the following default types: string, number, datetime and boolean . Custom types can be defined in the chaincode/datatypes folder. Validity : property validity function. It is suggested only for simple validations, more complex functions should use custom datatypes.","title":"Property definition"},{"location":"assets/#asset-examples","text":"The cc-tools-demo repository has the following examples: chaincode/ assettypes/ # asset foldgers person.go # definition of a person book.go # definition of a book library.go # definition of a library secret.go # definitions of secret (private data) assetTypeList.go # list of assets instantiated Besides the files of each asset, you must register the assets that can be used by the Goledger CC-Tools library in the assetTypeList.go file The definition of the Person asset is as follows: var Person = assets.AssetType{ Tag: \"person\", Label: \"Person\", Description: \"Personal data of someone\", Props: []assets.AssetProp{ { // Primary key Required: true, IsKey: true, Tag: \"id\", Label: \"CPF (Brazilian ID)\", DataType: \"cpf\", // Datatypes are identified at datatypes folder Writers: []string{`org1MSP`}, // This means only org1 can create the asset (others can edit) }, { // Mandatory property Required: true, Tag: \"name\", Label: \"Asset Name\", DataType: \"string\", // Validate funcion Validate: func(name interface{}) error { nameStr := name.(string) if nameStr == \"\" { return fmt.Errorf(\"name must be non-empty\") } return nil }, }, { // Optional property Tag: \"dateOfBirth\", Label: \"Date of Birth\", DataType: \"datetime\", }, { // Property with default value Tag: \"height\", Label: \"Person's height\", DefaultValue: 0, DataType: \"number\", }, }, } According to the description above, the asset Person has the following characteristics: Primary key cpf (custom datatype) Only org1 can create or change the cpf property and the Person asset (because this is a key) Property name of type string is mandatory, and has automatic validation to prevent empty strings (\"\") dateofBirth property of type datetime optional. height property of type number , with default value 0 The definition of the Book asset is as follows: var Book = assets.AssetType{ Tag: \"book\", Label: \"Book\", Description: \"\", Props: []assets.AssetProp{ { // Composite Key Required: true, IsKey: true, Tag: \"title\", Label: \"Book Title\", DataType: \"string\", Writers: []string{`org2MSP`}, // This means only org2 can create the asset (others can edit) }, { // Composite Key Required: true, IsKey: true, Tag: \"author\", Label: \"Book Author\", DataType: \"string\", Writers: []string{`org2MSP`}, // This means only org2 can create the asset (others can edit) }, { /// Reference to another asset Tag: \"currentTenant\", Label: \"Current Tenant\", DataType: \"->person\", }, { // String list Tag: \"genres\", Label: \"Genres\", DataType: \"[]string\", }, { // Date property Tag: \"published\", Label: \"Publishment Date\", DataType: \"datetime\", }, }, } According to the description above, the Book asset has the following characteristics: Composite key title and author , both with type string Only org2 can create or change the title and author properties and the Book asset (because they are keys) currentTenant property of type ->person which represents the reference to a Person asset genres property of type []string which represents an array of strings published property of type datetime The definition of the Library asset is as follows: var Library = assets.AssetType{ Tag: \"library\", Label: \"Library\", Description: \"Library as a collection of books\", Props: []assets.AssetProp{ { // Primary Key Required: true, IsKey: true, Tag: \"name\", Label: \"Library Name\", DataType: \"string\", Writers: []string{`org3MSP`}, // This means only org3 can create the asset (others can edit) }, { // Asset reference list Tag: \"books\", Label: \"Book Collection\", DataType: \"[]->book\", }, { // Asset reference list Tag: \"entranceCode\", Label: \"Entrance Code for the Library\", DataType: \"->secret\", }, }, } According to the description above, the Library asset has the following characteristics: Primary key name of type string Only org3 can create or change the name property and the Library asset (because it's key) books property of type []->book which represents an array of references to the Book asset entranceCode property of type ->secret which represents the reference to a private data type The definition of the Secret asset is as follows: var Secret = assets.AssetType{ Tag: \"secret\", Label: \"Secret\", Description: \"Secret between Org2 and Org3\", Readers: []string{\"org2MSP\", \"org3MSP\"}, Props: []assets.AssetProp{ { // Primary Key IsKey: true, Tag: \"secretName\", Label: \"Secret Name\", DataType: \"string\", Writers: []string{`org2MSP`}, // This means only org2 can create the asset (org3 can edit) }, { // Mandatory Property Required: true, Tag: \"secret\", Label: \"Secret\", DataType: \"string\", }, }, } According to the description above, Secret asset has privacy features ( Hyperledger Fabric Private Data ). For this asset to work correctly, the collections.json file must be configured We will not describe Hyperledger Fabric Private Data concepts, its operation, policy rules, etc. But to put it simply, when an asset is defined as private, only its content hash is recorded in channel , the asset's content (its properties) are only accessed by a limited set of organizations, the content recorded in transient databases in each peer. Asset content can only be read by org2 and org3 Primary key secretName of type string Only org2 can create or change the secretName property and the Secret asset (because it is key) secret property of type string is mandatory for the asset Both org2 and org3 can create or change the secret property The collections.json file needs to be configured according to the assets that have the Readers field [ { \"name\": \"secret\", \"policy\": { \"identities\": [ { \"role\": { \"name\": \"member\", \"mspId\": \"org2MSP\" } }, { \"role\": { \"name\": \"member\", \"mspId\": \"org3MSP\" } } ], \"policy\": { \"1-of\": [ { \"signed-by\": 0 }, { \"signed-by\": 1 } ] } }, \"requiredPeerCount\": 0, \"maxPeerCount\": 3, \"blockToLive\": 1000000, \"memberOnlyRead\": true } ]","title":"Asset examples"},{"location":"assets/#asset-list-definition","text":"GoLedger CC-Tools assets registration must be defined in the chaincode/assetTypeList.go file** var assetTypeList = []assets.AssetType{ assettypes.Person, assettypes.Book, assettypes.Library, assettypes.Secret, }","title":"Asset list definition"},{"location":"external-tools/","text":"External Tools GoLedger CC-Tools library has a range of external tools that help immensely in the journey of developing a permissioned Blockchain based on Hyperledger Fabric cc-tools-demo - public repository with example assets and transactions using GoLedger CC-Tools library cc-webclient - docker image with web application to interconnect with Rest Api. GoFabric - network orchestration platform for production environments. https://gofabric.io cc-tools-demo Open repository with examples and transactions. The repository can be accessed as follows: git clone https://github.com/goledgerdev/cc-tools-demo.git cc-web-client Docker image providing web application for testing. The container can be instantiated as follows: docker run -p 0.0.0.0:8080:80/tcp --name cc-webclient goledger/cc-webclient:latest GoFabric GoFabric is a Hyperledger Fabric Blockchain orchestration platform fully compatible with GoLedger CC-Tools library The platform can be accessed at the following link: https://gofabric.io and has the following features: Deployment of cloud environment networks ( AWS, IBM, Azure, etc ) or on-premise Instantiate chaincodes ( compatibility with CC-Tools ) Update chaincodes Add or remove peers Add orderers Add orgs Instantiate or update Rest Servers Automatic code generation GoLedger Templates","title":"External Tools"},{"location":"external-tools/#external-tools","text":"GoLedger CC-Tools library has a range of external tools that help immensely in the journey of developing a permissioned Blockchain based on Hyperledger Fabric cc-tools-demo - public repository with example assets and transactions using GoLedger CC-Tools library cc-webclient - docker image with web application to interconnect with Rest Api. GoFabric - network orchestration platform for production environments. https://gofabric.io","title":"External Tools"},{"location":"external-tools/#cc-tools-demo","text":"Open repository with examples and transactions. The repository can be accessed as follows: git clone https://github.com/goledgerdev/cc-tools-demo.git","title":"cc-tools-demo"},{"location":"external-tools/#cc-web-client","text":"Docker image providing web application for testing. The container can be instantiated as follows: docker run -p 0.0.0.0:8080:80/tcp --name cc-webclient goledger/cc-webclient:latest","title":"cc-web-client"},{"location":"external-tools/#gofabric","text":"GoFabric is a Hyperledger Fabric Blockchain orchestration platform fully compatible with GoLedger CC-Tools library The platform can be accessed at the following link: https://gofabric.io and has the following features: Deployment of cloud environment networks ( AWS, IBM, Azure, etc ) or on-premise Instantiate chaincodes ( compatibility with CC-Tools ) Update chaincodes Add or remove peers Add orderers Add orgs Instantiate or update Rest Servers Automatic code generation GoLedger Templates","title":"GoFabric"},{"location":"getting-started/","text":"Getting Started GoLedger CC-Tools library was developed to be used in Linux operating system. In general we use the Ubuntu 18+ distribution, however the library is compatible with other environments, but some adjustments may be necessary. Download and setup To learn how to use GoLedger CC-Tools library , download the demo code repository available on GitHub . cd $HOME \\ git clone https://github.com/goledgerdev/cc-tools-demo.git \\ cd cc-tools-demo Folder distribution . // cc-tools-demo root folder | \u251c\u2500\u2500 chaincode // Smart contract code (GoLang) | \u2514\u2500\u2500 assettypes // Asset definitions | \u2514\u2500\u2500 txdefs // Blockchain transactions | \u2514\u2500\u2500 datatypes // Custom property datatypes | \u251c\u2500\u2500 rest-server // Rest API code (NodeJs) | \u251c\u2500\u2500 fabric // Hyperledger Fabric artifacts These are all the necessary elements to use the main functions of the library. Enviroment configuration The following systems, platforms and languages \u200b\u200bmust be installed: Docker 19+ GCC GoLang 1.14+ NodeJs 10+ Hyperledger Fabric 1.4 (Hyperledger Fabric 2.x in roadmap) If you are using Linux Ubuntu , run the following command from the root directory. This will download and install the systems above before starting development. ./installPreReqUbuntu.sh At the end, the following success message should appear. Enviroment configured Now you're ready to Write Your First Application .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"GoLedger CC-Tools library was developed to be used in Linux operating system. In general we use the Ubuntu 18+ distribution, however the library is compatible with other environments, but some adjustments may be necessary.","title":"Getting Started"},{"location":"getting-started/#download-and-setup","text":"To learn how to use GoLedger CC-Tools library , download the demo code repository available on GitHub . cd $HOME \\ git clone https://github.com/goledgerdev/cc-tools-demo.git \\ cd cc-tools-demo","title":"Download and setup"},{"location":"getting-started/#folder-distribution","text":". // cc-tools-demo root folder | \u251c\u2500\u2500 chaincode // Smart contract code (GoLang) | \u2514\u2500\u2500 assettypes // Asset definitions | \u2514\u2500\u2500 txdefs // Blockchain transactions | \u2514\u2500\u2500 datatypes // Custom property datatypes | \u251c\u2500\u2500 rest-server // Rest API code (NodeJs) | \u251c\u2500\u2500 fabric // Hyperledger Fabric artifacts These are all the necessary elements to use the main functions of the library.","title":"Folder distribution"},{"location":"getting-started/#enviroment-configuration","text":"The following systems, platforms and languages \u200b\u200bmust be installed: Docker 19+ GCC GoLang 1.14+ NodeJs 10+ Hyperledger Fabric 1.4 (Hyperledger Fabric 2.x in roadmap) If you are using Linux Ubuntu , run the following command from the root directory. This will download and install the systems above before starting development. ./installPreReqUbuntu.sh At the end, the following success message should appear. Enviroment configured Now you're ready to Write Your First Application .","title":"Enviroment configuration"},{"location":"testing/","text":"Testing GoLedger CC-Tools has different ways for testing the source code in development mode. For GoLang syntax checking, execute the following command: cd chaincode \\ go vet After the succesfull code instantiation or update, you can check the logs directly inside the chaincode execution peers containers. These containers can be identified by starting with dev . docker logs dev-peer0.org1.example.com-cc-tools-demo-0.1 Using cc-webclient To perform the tests and integrations satisfactorily, it is suggested the usage of cc-webclient tool. After finishing the steps, it is suggested to execute the following commands to create 3 applications in order to connect with org1, org2 and org3 . ./run-cc-web.sh 8080 & \\ ./run-cc-web.sh 8090 & \\ ./run-cc-web.sh 8100 & Configuring rest-server and cc-webclient After executing cc-webclient containers, the applications can be accessed directly through the ports defined in the script. E.g.: 8080, 8090, 8100 After accessing cc-webclient through the browser, the configuration of rest server address can be done by clicking on the tool icon. Accesses are can be made with the following settings: org1 : http://localhost:80 org2 : http://localhost:980 org3 : http://localhost:1080 cc-webclient application has a sidebar that shows the available assets as well as the transactions registered in the chaincode. Endpoint usage The rest-server endpoint usage is shown using the CURL buttons. For each screen, you can check endpoint usage pressing the curl button. For example, on the asset creation screen: List, create, edit, delete or history an asset To list each asset, just select an asset in the sidebar. Selecting the CREATE button at the asset list window, an asset creation screen will appear. For example, for the Person asset The edit screen is accessed by selecting the edit icon in an asset's list window. The removal of an asset is requested by selecting the delete icon in the asset's list window. The history of an asset (all changes recorded in the ledger) can be viewed by selecting the history icon in an asset's window. Executing an transaction The transaction execution can be performed by selecting the transaction in the sidebar. For example, for transaction UpdateBookTenant","title":"Testing"},{"location":"testing/#testing","text":"GoLedger CC-Tools has different ways for testing the source code in development mode. For GoLang syntax checking, execute the following command: cd chaincode \\ go vet After the succesfull code instantiation or update, you can check the logs directly inside the chaincode execution peers containers. These containers can be identified by starting with dev . docker logs dev-peer0.org1.example.com-cc-tools-demo-0.1","title":"Testing"},{"location":"testing/#using-cc-webclient","text":"To perform the tests and integrations satisfactorily, it is suggested the usage of cc-webclient tool. After finishing the steps, it is suggested to execute the following commands to create 3 applications in order to connect with org1, org2 and org3 . ./run-cc-web.sh 8080 & \\ ./run-cc-web.sh 8090 & \\ ./run-cc-web.sh 8100 &","title":"Using cc-webclient"},{"location":"testing/#configuring-rest-server-and-cc-webclient","text":"After executing cc-webclient containers, the applications can be accessed directly through the ports defined in the script. E.g.: 8080, 8090, 8100 After accessing cc-webclient through the browser, the configuration of rest server address can be done by clicking on the tool icon. Accesses are can be made with the following settings: org1 : http://localhost:80 org2 : http://localhost:980 org3 : http://localhost:1080 cc-webclient application has a sidebar that shows the available assets as well as the transactions registered in the chaincode.","title":"Configuring rest-server and cc-webclient"},{"location":"testing/#endpoint-usage","text":"The rest-server endpoint usage is shown using the CURL buttons. For each screen, you can check endpoint usage pressing the curl button. For example, on the asset creation screen:","title":"Endpoint usage"},{"location":"testing/#list-create-edit-delete-or-history-an-asset","text":"To list each asset, just select an asset in the sidebar. Selecting the CREATE button at the asset list window, an asset creation screen will appear. For example, for the Person asset The edit screen is accessed by selecting the edit icon in an asset's list window. The removal of an asset is requested by selecting the delete icon in the asset's list window. The history of an asset (all changes recorded in the ledger) can be viewed by selecting the history icon in an asset's window.","title":"List, create, edit, delete or history an asset"},{"location":"testing/#executing-an-transaction","text":"The transaction execution can be performed by selecting the transaction in the sidebar. For example, for transaction UpdateBookTenant","title":"Executing an transaction"},{"location":"transactions/","text":"Transactions GoLedger CC-Tools transactions represent the GoLang methods that can modify the assets within the Blockchain ledger ( Hyperledger Fabric Channel ) Hyperledger Fabric assets can only be created or modified by executing chaincode transactions inside endorsing peers. Goledger CC-Tools library has a range of pre-defined transactions: CreateAsset - creation of a new asset UpdateAsset - update an existing asset DeleteAsset - removing an asset from the current ledger state ReadAsset - read the asset in its last ledger status ReadAssetHistory - history of an asset's ledger status Search - asset listing GoLedger CC-Tools library enables the creation of custom transactions. cc-tools-demo repository provides 3 example transactions: CreateNewLibrary - create a new asset of type Library GetNumberOfBooksFromLibrary - returns the number of assets Book inside asset Library UpdateBookTenant - update field currentTenant inside asset Book The definition of assets is done in the chaincode/txdefs folder for GoLedger CC-Tools library. The of files from the txdefs folder is shown below: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions Transaction definition A custom transaction construction is done by creating a file inside the chaincode/txdefs folder An asset has the following fields: Tag : string field to define the transaction name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. If it has the same name as a predefined transaction ( createAsset , updateAsset , deleteAsset , readAsset , readAssetHistory or search ), this transaction will be replaced by the one in the txdefs directory. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Method : Rest API method type. It can be POST , GET , PUT or DELETE . Callers : used to define which organizations can call this transaction. Args : arguments. It has its own fields. Routine : transaction source code. Transaction argument definition A transaction has a set of customizable input arguments. An argument has the following fields: Tag : string field to define the argument name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Required : identifies if the argument is required. Boolean field. DataType : property type. CC-Tools has the following default types: string, number, datetime and boolean . Transaction examples cc-tools-demo repository has the following custom transaction configuration: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions In addition to the files for each transaction that can be used by the Goledger CC-Tools library they also must be registered inside txList.go file The definition of the CreateNewLibrary transaction is as follows: var CreateNewLibrary = tx.Transaction{ Tag: \"createNewLibrary\", Label: \"Create New Library\", Description: \"Create a New Library\", Method: \"POST\", Callers: []string{\"$org3MSP\"}, // Only org3 can call this transaction Args: []tx.Argument{ { Tag: \"name\", Label: \"Name\", Description: \"Name of the library\", DataType: \"string\", Required: true, }, }, Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) { name, ok := req[\"name\"].(string) if !ok { return nil, errors.WrapError(nil, \"Parameter name must be string\") } libraryMap := make(map[string]interface{}) libraryMap[\"@assetType\"] = \"library\" libraryMap[\"name\"] = name libraryAsset, err := assets.NewAsset(libraryMap) if err != nil { return nil, errors.WrapError(err, \"Failed to create a new asset\") } // Save the new library on channel _, err = libraryAsset.PutNew(stub) if err != nil { return nil, errors.WrapError(err, \"Error saving asset on blockchain\") } // Marshal asset back to JSON format libraryJSON, nerr := json.Marshal(libraryAsset) if nerr != nil { return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\") } return libraryJSON, nil }, } According to the description above, CreateNewLibrary transaction has the following characteristics: Only org3 can call this method POST method for Rest Api Argument name of type string is required. The transaction uses the NewAsset function to prepare a new asset (keys, etc) and the PutNew function to create the asset in the channel . The definition of the UpdateBookTenant transaction is as follows: var UpdateBookTenant = tx.Transaction{ Tag: \"updateBookTenant\", Label: \"Update Book Tenant\", Description: \"Change the tenant of a book\", Method: \"PUT\", Callers: []string{`$org\\dMSP`}, // Any orgs can call this transaction Args: []tx.Argument{ { Tag: \"book\", Label: \"Book\", Description: \"Book\", DataType: \"book\", Required: true, }, { Tag: \"tenant\", Label: \"tenant\", Description: \"New tenant of the book\", DataType: \"person\", }, }, Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) { bookKey, ok := req[\"book\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter book must be an asset\") } tenantKey, ok := req[\"tenant\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter tenant must be an asset\") } // Returns Book from channel bookAsset, err := bookKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } bookMap := (map[string]interface{})(*bookAsset) if bookMap[\"@assetType\"].(string) != \"book\" { return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\") } // Returns person from channel tenantAsset, err := tenantKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } tenantMap := (map[string]interface{})(*tenantAsset) if tenantMap[\"@assetType\"].(string) != \"person\" { return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\") } // Update data bookMap[\"tenant\"] = tenantMap bookMap, nerr := bookAsset.Update(stub, bookMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to update asset\") } // Marshal asset back to JSON format bookJSON, nerr := json.Marshal(bookAsset) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return bookJSON, nil }, } Any organization that starts with \"org\" followed by a number (org1, org2, org3, org4, etc) can call this method. PUT method for Rest Api Argument book of type Book is mandatory. Argument person of type Person required. The transaction uses the Get function to read the the assets Book and Person information from the ledger The transaction uses the Update function to updates the asset information Book inside the ledger The definition of the GetNumberOfBooksFromLibrary transaction is as follows: var GetNumberOfBooksFromLibrary = tx.Transaction{ Tag: \"getNumberOfBooksFromLibrary\", Label: \"Get Number Of Books From Library\", Description: \"Return the number of books of a library\", Method: \"GET\", Callers: []string{\"$org2MSP\"}, // Only org2 can call this transactions Args: []tx.Argument{ { Tag: \"library\", Label: \"Library\", Description: \"Library\", DataType: \"library\", Required: true, }, }, Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) { libraryKey, ok := req[\"library\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter library must be an asset\") } // Returns Library from channel libraryAsset, err := libraryKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } libraryMap := (map[string]interface{})(*libraryAsset) if libraryMap[\"@assetType\"].(string) != \"library\" { return nil, errors.WrapError(err, \"failed to get library from the ledger\") } numberOfBooks := 0 books, ok := libraryMap[\"books\"].([]interface{}) if ok { numberOfBooks = len(books) } var returnMap map[string]interface{} returnMap[\"numberOfBooks\"] = numberOfBooks // Marshal asset back to JSON format returnJSON, nerr := json.Marshal(returnMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return returnJSON, nil }, } Only org2 can call this method. GET method for Rest Api Argument library of type Library is required. The transaction uses the Get function to read Library asset information from the ledger Transaction list definition The registration of the transactions that will be used by GoLedger CC-Tools library must be also done inside chaincode/txList.go file var txList = []tx.Transaction{ txdefs.GetHeader, txdefs.CreateNewLibrary, txdefs.GetNumberOfBooksFromLibrary, txdefs.UpdateBookTenant, }","title":"Transactions"},{"location":"transactions/#transactions","text":"GoLedger CC-Tools transactions represent the GoLang methods that can modify the assets within the Blockchain ledger ( Hyperledger Fabric Channel ) Hyperledger Fabric assets can only be created or modified by executing chaincode transactions inside endorsing peers. Goledger CC-Tools library has a range of pre-defined transactions: CreateAsset - creation of a new asset UpdateAsset - update an existing asset DeleteAsset - removing an asset from the current ledger state ReadAsset - read the asset in its last ledger status ReadAssetHistory - history of an asset's ledger status Search - asset listing GoLedger CC-Tools library enables the creation of custom transactions. cc-tools-demo repository provides 3 example transactions: CreateNewLibrary - create a new asset of type Library GetNumberOfBooksFromLibrary - returns the number of assets Book inside asset Library UpdateBookTenant - update field currentTenant inside asset Book The definition of assets is done in the chaincode/txdefs folder for GoLedger CC-Tools library. The of files from the txdefs folder is shown below: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions","title":"Transactions"},{"location":"transactions/#transaction-definition","text":"A custom transaction construction is done by creating a file inside the chaincode/txdefs folder An asset has the following fields: Tag : string field to define the transaction name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. If it has the same name as a predefined transaction ( createAsset , updateAsset , deleteAsset , readAsset , readAssetHistory or search ), this transaction will be replaced by the one in the txdefs directory. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Method : Rest API method type. It can be POST , GET , PUT or DELETE . Callers : used to define which organizations can call this transaction. Args : arguments. It has its own fields. Routine : transaction source code.","title":"Transaction definition"},{"location":"transactions/#transaction-argument-definition","text":"A transaction has a set of customizable input arguments. An argument has the following fields: Tag : string field to define the argument name internally referenced by the code and by the Rest Api endpoints. It cannot have spaces or special characters. Label : string field to define the label to be used by external applications. Free text. Description : asset description string field to be used by external applications. Free text. Required : identifies if the argument is required. Boolean field. DataType : property type. CC-Tools has the following default types: string, number, datetime and boolean .","title":"Transaction argument definition"},{"location":"transactions/#transaction-examples","text":"cc-tools-demo repository has the following custom transaction configuration: chaincode/ txdefs/ # transations folder createNewLibrary.go # library creation getNumberOfBooksFromLibrary.go # returns the number of books at the library asset updateBookTenant.go # changes de tenant of book txList.go # list of custom transactions In addition to the files for each transaction that can be used by the Goledger CC-Tools library they also must be registered inside txList.go file The definition of the CreateNewLibrary transaction is as follows: var CreateNewLibrary = tx.Transaction{ Tag: \"createNewLibrary\", Label: \"Create New Library\", Description: \"Create a New Library\", Method: \"POST\", Callers: []string{\"$org3MSP\"}, // Only org3 can call this transaction Args: []tx.Argument{ { Tag: \"name\", Label: \"Name\", Description: \"Name of the library\", DataType: \"string\", Required: true, }, }, Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) { name, ok := req[\"name\"].(string) if !ok { return nil, errors.WrapError(nil, \"Parameter name must be string\") } libraryMap := make(map[string]interface{}) libraryMap[\"@assetType\"] = \"library\" libraryMap[\"name\"] = name libraryAsset, err := assets.NewAsset(libraryMap) if err != nil { return nil, errors.WrapError(err, \"Failed to create a new asset\") } // Save the new library on channel _, err = libraryAsset.PutNew(stub) if err != nil { return nil, errors.WrapError(err, \"Error saving asset on blockchain\") } // Marshal asset back to JSON format libraryJSON, nerr := json.Marshal(libraryAsset) if nerr != nil { return nil, errors.WrapError(nil, \"failed to encode asset to JSON format\") } return libraryJSON, nil }, } According to the description above, CreateNewLibrary transaction has the following characteristics: Only org3 can call this method POST method for Rest Api Argument name of type string is required. The transaction uses the NewAsset function to prepare a new asset (keys, etc) and the PutNew function to create the asset in the channel . The definition of the UpdateBookTenant transaction is as follows: var UpdateBookTenant = tx.Transaction{ Tag: \"updateBookTenant\", Label: \"Update Book Tenant\", Description: \"Change the tenant of a book\", Method: \"PUT\", Callers: []string{`$org\\dMSP`}, // Any orgs can call this transaction Args: []tx.Argument{ { Tag: \"book\", Label: \"Book\", Description: \"Book\", DataType: \"book\", Required: true, }, { Tag: \"tenant\", Label: \"tenant\", Description: \"New tenant of the book\", DataType: \"person\", }, }, Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) { bookKey, ok := req[\"book\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter book must be an asset\") } tenantKey, ok := req[\"tenant\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter tenant must be an asset\") } // Returns Book from channel bookAsset, err := bookKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } bookMap := (map[string]interface{})(*bookAsset) if bookMap[\"@assetType\"].(string) != \"book\" { return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\") } // Returns person from channel tenantAsset, err := tenantKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } tenantMap := (map[string]interface{})(*tenantAsset) if tenantMap[\"@assetType\"].(string) != \"person\" { return nil, errors.WrapError(err, \"failed to get solicitacao from the ledger\") } // Update data bookMap[\"tenant\"] = tenantMap bookMap, nerr := bookAsset.Update(stub, bookMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to update asset\") } // Marshal asset back to JSON format bookJSON, nerr := json.Marshal(bookAsset) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return bookJSON, nil }, } Any organization that starts with \"org\" followed by a number (org1, org2, org3, org4, etc) can call this method. PUT method for Rest Api Argument book of type Book is mandatory. Argument person of type Person required. The transaction uses the Get function to read the the assets Book and Person information from the ledger The transaction uses the Update function to updates the asset information Book inside the ledger The definition of the GetNumberOfBooksFromLibrary transaction is as follows: var GetNumberOfBooksFromLibrary = tx.Transaction{ Tag: \"getNumberOfBooksFromLibrary\", Label: \"Get Number Of Books From Library\", Description: \"Return the number of books of a library\", Method: \"GET\", Callers: []string{\"$org2MSP\"}, // Only org2 can call this transactions Args: []tx.Argument{ { Tag: \"library\", Label: \"Library\", Description: \"Library\", DataType: \"library\", Required: true, }, }, Routine: func(stub shim.ChaincodeStubInterface, req map[string]interface{}) ([]byte, errors.ICCError) { libraryKey, ok := req[\"library\"].(assets.Key) if !ok { return nil, errors.WrapError(nil, \"Parameter library must be an asset\") } // Returns Library from channel libraryAsset, err := libraryKey.Get(stub) if err != nil { return nil, errors.WrapError(err, \"failed to get asset from the ledger\") } libraryMap := (map[string]interface{})(*libraryAsset) if libraryMap[\"@assetType\"].(string) != \"library\" { return nil, errors.WrapError(err, \"failed to get library from the ledger\") } numberOfBooks := 0 books, ok := libraryMap[\"books\"].([]interface{}) if ok { numberOfBooks = len(books) } var returnMap map[string]interface{} returnMap[\"numberOfBooks\"] = numberOfBooks // Marshal asset back to JSON format returnJSON, nerr := json.Marshal(returnMap) if nerr != nil { return nil, errors.WrapError(err, \"failed to marshal response\") } return returnJSON, nil }, } Only org2 can call this method. GET method for Rest Api Argument library of type Library is required. The transaction uses the Get function to read Library asset information from the ledger","title":"Transaction examples"},{"location":"transactions/#transaction-list-definition","text":"The registration of the transactions that will be used by GoLedger CC-Tools library must be also done inside chaincode/txList.go file var txList = []tx.Transaction{ txdefs.GetHeader, txdefs.CreateNewLibrary, txdefs.GetNumberOfBooksFromLibrary, txdefs.UpdateBookTenant, }","title":"Transaction list definition"},{"location":"tutorials/","text":"Tutorials Writing Your First Application This tutorial will show how to install and use a smart contract (chaincode). You must already have configured the environment to be able to perform this tutorial. Details on Getting Started We'll see how the GoLedger CC-Tools library works, using the artifacts provided by GoLedger Rest-server integration Hyperledger Fabric Update API Development web application (cc-web) The cc-tools-demo repository smart contract is ideal for beginners to Hyperledger Fabric technology development. It's a great starting point to understand a Hyperledger Fabric blockchain and ease the journey of application development using this framework. You'll learn how to write an application and a smart contract (chaincode) to query and update a ledger, and how to connect to the Blockchain through a ready-to-use API. NOTE You need to know GoLang programming language in order to complete this tutorial. Network Details The network to be created will have the following configuration: 1 chaincode (cc-tools-demo) 3 orgs (org1, org2, org3) 3 clients (rest-server para as org1, org2 e org3) Chaincode Details The chaincode provided in cc-tools-demo has the following characteristics: 3 assets 1 private data 3 transactions MSP Configuration Hyperledger Fabric networks require the correct configuration of x.509 digital certificates grouped in elements called Membership Service Provider or simply called MSP Certificates are generated and managed by certification authorities ( CA ) using the Hyperledger Fabric CA platform. Each organization (org1, org2 and org3) will be represented by a unique CA NOTE It is not the purpose of this tutorial to teach the concepts of MSP or Hyperledger Fabric CA , for that check the official HF Docs . The generation of certificates and MSP necessary for network generation is performed through the script below to be executed in the ./fabric folder: cd fabric \\ rm -rf crypto-config channel-artifacts ca && \\ ./startDev.sh generate && \\ cd .. This will deploy 3 containers of Hyperledger Fabric CA ca.org1.example.com ca.org2.example.com ca.org3.example.com After the script finishes, 3 folders will be created with the cryptographic artifacts necessary to generate the network: . \u251c\u2500\u2500 fabric \u2514\u2500\u2500 ca \u2514\u2500\u2500 crypto-config \u2514\u2500\u2500 channel-artifacts Vendoring Both the chaincode in GoLang and the rest-server in Node.js need to be vendored (dependency packages download) in order to work. To download chaincode dependencies, run the following script: cd chaincode && \\ go mod vendor && \\ cd .. To download the rest-server dependencies, run the following script: cd rest-server && \\ npm install && \\ cd .. Building your GoLedger CC-Tools network After installing the environment, generating the certificates and vendoring the packages, the network is ready to be instantiated. This process takes place with the following script ./startDev.sh This script will perform the following tasks: Create the Blockchain node containers ( Hyperledger Fabric peers and orderers) for 3 orgs (org1, org2, org3) with the correct cryptographic configuration for each one of them. Create the ledger for registration and permission - Hyperledger Fabric Channel Organizations entries in the channel (Join process in Hyperledger Fabric ) Chaincode installation inside endorsing peers Installation of network management api Hyperledger Fabric Chaincode instantiation on the channel Rest servers containers deployment with the correct cryptographic configuration, representing a Hyperledger Fabric Client for each organization. At the end of the process, the following messages should be displayed: Create channel - mainchannel {\"status\":\"SUCCESS\",\"created\":true} Join org1 to channel {\"status\":\"SUCCESS\"} Join org2 to channel {\"status\":\"SUCCESS\"} Join org3 to channel {\"status\":\"SUCCESS\"} Update anchor peers on org1 {\"status\":\"SUCCESS\"} Update anchor peers on org2 {\"status\":\"SUCCESS\"} Update anchor peers on org3 {\"status\":\"SUCCESS\"} Install network chaincode on org1 {\"installed\":true,\"version\":\"1.0\"} Install network chaincode on org2 {\"installed\":true,\"version\":\"1.0\"} Install network chaincode on org3 {\"installed\":true,\"version\":\"1.0\"} Instantiate network chaincode {\"started\":true} Install chaincode on org1 Install chaincode on org2 Install chaincode on org3 Instantiate chaincode {\"started\":true} Network cc-tools-demo-net is external, skipping Creating ccapi.org1.example.com ... done Creating ccapi.org2.example.com ... done Creating ccapi.org3.example.com ... done The ccapi containers represent the rest servers for each organization. They may take a few minutes to come online. At the end, the following message should appear: docker logs ccapi.org1.example.com > cc-tools-demoapi@1.0.0 start /rest-server > gulp default; gulp start [23:12:58] Using gulpfile /rest-server/gulpfile.js [23:12:58] Starting 'default'... [23:12:58] Starting 'assets'... [23:12:59] Finished 'default' after 49 ms [23:12:59] Finished 'assets' after 51 ms [23:13:40] Using gulpfile /rest-server/gulpfile.js [23:13:40] Starting 'start'... [23:13:41] [nodemon] 1.19.0 [23:13:41] [nodemon] to restart at any time, enter `rs` [23:13:41] [nodemon] watching: /rest-server/src/**/* [23:13:41] [nodemon] starting `node dist/` Listening on port 80 Updating your chaincode Updating a smart contract can be done easily in chaincodes that use the GoLedger CC-Tools library. First, you must check the syntax of the modified code. cd chaincode \\ go vet \\ cd .. After validation, the chaincode update is done with the upgradeCC.sh script, which takes the chaincode version as argument. NOTE A chaincode must always be updated with a version different from all previous versions. Example: ./upgradeCC.sh 0.2","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#writing-your-first-application","text":"This tutorial will show how to install and use a smart contract (chaincode). You must already have configured the environment to be able to perform this tutorial. Details on Getting Started We'll see how the GoLedger CC-Tools library works, using the artifacts provided by GoLedger Rest-server integration Hyperledger Fabric Update API Development web application (cc-web) The cc-tools-demo repository smart contract is ideal for beginners to Hyperledger Fabric technology development. It's a great starting point to understand a Hyperledger Fabric blockchain and ease the journey of application development using this framework. You'll learn how to write an application and a smart contract (chaincode) to query and update a ledger, and how to connect to the Blockchain through a ready-to-use API. NOTE You need to know GoLang programming language in order to complete this tutorial.","title":"Writing Your First Application"},{"location":"tutorials/#network-details","text":"The network to be created will have the following configuration: 1 chaincode (cc-tools-demo) 3 orgs (org1, org2, org3) 3 clients (rest-server para as org1, org2 e org3)","title":"Network Details"},{"location":"tutorials/#chaincode-details","text":"The chaincode provided in cc-tools-demo has the following characteristics: 3 assets 1 private data 3 transactions","title":"Chaincode Details"},{"location":"tutorials/#msp-configuration","text":"Hyperledger Fabric networks require the correct configuration of x.509 digital certificates grouped in elements called Membership Service Provider or simply called MSP Certificates are generated and managed by certification authorities ( CA ) using the Hyperledger Fabric CA platform. Each organization (org1, org2 and org3) will be represented by a unique CA NOTE It is not the purpose of this tutorial to teach the concepts of MSP or Hyperledger Fabric CA , for that check the official HF Docs . The generation of certificates and MSP necessary for network generation is performed through the script below to be executed in the ./fabric folder: cd fabric \\ rm -rf crypto-config channel-artifacts ca && \\ ./startDev.sh generate && \\ cd .. This will deploy 3 containers of Hyperledger Fabric CA ca.org1.example.com ca.org2.example.com ca.org3.example.com After the script finishes, 3 folders will be created with the cryptographic artifacts necessary to generate the network: . \u251c\u2500\u2500 fabric \u2514\u2500\u2500 ca \u2514\u2500\u2500 crypto-config \u2514\u2500\u2500 channel-artifacts","title":"MSP Configuration"},{"location":"tutorials/#vendoring","text":"Both the chaincode in GoLang and the rest-server in Node.js need to be vendored (dependency packages download) in order to work. To download chaincode dependencies, run the following script: cd chaincode && \\ go mod vendor && \\ cd .. To download the rest-server dependencies, run the following script: cd rest-server && \\ npm install && \\ cd ..","title":"Vendoring"},{"location":"tutorials/#building-your-goledger-cc-tools-network","text":"After installing the environment, generating the certificates and vendoring the packages, the network is ready to be instantiated. This process takes place with the following script ./startDev.sh This script will perform the following tasks: Create the Blockchain node containers ( Hyperledger Fabric peers and orderers) for 3 orgs (org1, org2, org3) with the correct cryptographic configuration for each one of them. Create the ledger for registration and permission - Hyperledger Fabric Channel Organizations entries in the channel (Join process in Hyperledger Fabric ) Chaincode installation inside endorsing peers Installation of network management api Hyperledger Fabric Chaincode instantiation on the channel Rest servers containers deployment with the correct cryptographic configuration, representing a Hyperledger Fabric Client for each organization. At the end of the process, the following messages should be displayed: Create channel - mainchannel {\"status\":\"SUCCESS\",\"created\":true} Join org1 to channel {\"status\":\"SUCCESS\"} Join org2 to channel {\"status\":\"SUCCESS\"} Join org3 to channel {\"status\":\"SUCCESS\"} Update anchor peers on org1 {\"status\":\"SUCCESS\"} Update anchor peers on org2 {\"status\":\"SUCCESS\"} Update anchor peers on org3 {\"status\":\"SUCCESS\"} Install network chaincode on org1 {\"installed\":true,\"version\":\"1.0\"} Install network chaincode on org2 {\"installed\":true,\"version\":\"1.0\"} Install network chaincode on org3 {\"installed\":true,\"version\":\"1.0\"} Instantiate network chaincode {\"started\":true} Install chaincode on org1 Install chaincode on org2 Install chaincode on org3 Instantiate chaincode {\"started\":true} Network cc-tools-demo-net is external, skipping Creating ccapi.org1.example.com ... done Creating ccapi.org2.example.com ... done Creating ccapi.org3.example.com ... done The ccapi containers represent the rest servers for each organization. They may take a few minutes to come online. At the end, the following message should appear: docker logs ccapi.org1.example.com > cc-tools-demoapi@1.0.0 start /rest-server > gulp default; gulp start [23:12:58] Using gulpfile /rest-server/gulpfile.js [23:12:58] Starting 'default'... [23:12:58] Starting 'assets'... [23:12:59] Finished 'default' after 49 ms [23:12:59] Finished 'assets' after 51 ms [23:13:40] Using gulpfile /rest-server/gulpfile.js [23:13:40] Starting 'start'... [23:13:41] [nodemon] 1.19.0 [23:13:41] [nodemon] to restart at any time, enter `rs` [23:13:41] [nodemon] watching: /rest-server/src/**/* [23:13:41] [nodemon] starting `node dist/` Listening on port 80","title":"Building your GoLedger CC-Tools network"},{"location":"tutorials/#updating-your-chaincode","text":"Updating a smart contract can be done easily in chaincodes that use the GoLedger CC-Tools library. First, you must check the syntax of the modified code. cd chaincode \\ go vet \\ cd .. After validation, the chaincode update is done with the upgradeCC.sh script, which takes the chaincode version as argument. NOTE A chaincode must always be updated with a version different from all previous versions. Example: ./upgradeCC.sh 0.2","title":"Updating your chaincode"}]}